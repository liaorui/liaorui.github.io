<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Java">
<meta property="og:type" content="website">
<meta property="og:title" content="TechLiving">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="TechLiving">
<meta property="og:description" content="Java">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TechLiving">
<meta name="twitter:description" content="Java">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>TechLiving</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">TechLiving</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Technology and Life</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/29/Copycat-Raft之领导选举/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Rui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TechLiving">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/29/Copycat-Raft之领导选举/" itemprop="url">Copycat Raft之领导者选举</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-29T09:19:22+08:00">
                2018-06-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/29/Copycat-Raft之领导选举/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/29/Copycat-Raft之领导选举/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Raft是一种基于日志复制的分布式一致性算法，它提供了和Paxos算法相同的功能和性能，但更容易理解并且更容易构建实际的系统。Raft将一致性算法分解成了几个关键模块，包括领导者选举、日志复制和安全性。</p>
<p>Raft算法定义了Follower、Candidate和Leader三个角色，服务节点可以在这三个状态进行切换。<br><img src="/2018/06/29/Copycat-Raft之领导选举/raft-states.png" alt=""></p>
<p>Raft算法最著名的实现是<a href="https://github.com/coreos/etcd/tree/master/raft" target="_blank" rel="noopener">etcd/raft</a>和<a href="https://github.com/hashicorp/raft" target="_blank" rel="noopener">hashicorp/raft</a>，前者是<a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">etcd</a>的实现基础，后者是<a href="https://github.com/hashicorp/consul" target="_blank" rel="noopener">consul</a>的实现基础。它们都是用Go语言实现的，更多语言实现请参见 <a href="https://raft.github.io。" target="_blank" rel="noopener">https://raft.github.io。</a></p>
<p><a href="https://github.com/atomix/copycat" target="_blank" rel="noopener">copycat</a>是raft的一个Java实现，实现了领导者选举、日志复制、角色切换和日志压缩等功能。</p>
<p>下面结合源码分析一下copycat对领导者选举的实现过程。</p>
<p><img src="/2018/06/29/Copycat-Raft之领导选举/copycat-leader selection.png" alt=""></p>
<p>通过CopycatServer.builder()方法构造CopycatServer实例，再通过bootstrap()方法启动。bootstrap()方法会调用ClusterState类的bootstrap()方法，注意所有ServerMember的type是ACTIVE类型的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Create a set of cluster members, excluding the local member which is joining a cluster.</span><br><span class="line">Set&lt;Member&gt; activeMembers = cluster.stream()</span><br><span class="line">    .filter(m -&gt; !m.equals(member.serverAddress()))</span><br><span class="line">    .map(m -&gt; new ServerMember(Member.Type.ACTIVE, m, null, member.updated()))</span><br><span class="line">    .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure></p>
<p>ClusterState的join()方法里继续调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Transition the server to the appropriate state for the local member type.</span><br><span class="line">context.transition(member.type());</span><br></pre></td></tr></table></figure></p>
<p>这里的context是ServerContext类的实例，member.type()是ACTIVE。transition()方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">protected void transition(Member.Type type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">      case ACTIVE:</span><br><span class="line">        if (!(state instanceof ActiveState)) &#123;</span><br><span class="line">          transition(CopycatServer.State.FOLLOWER);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      case PASSIVE:</span><br><span class="line">        if (this.state.type() != CopycatServer.State.PASSIVE) &#123;</span><br><span class="line">          transition(CopycatServer.State.PASSIVE);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      case RESERVE:</span><br><span class="line">        if (this.state.type() != CopycatServer.State.RESERVE) &#123;</span><br><span class="line">          transition(CopycatServer.State.RESERVE);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        if (this.state.type() != CopycatServer.State.INACTIVE) &#123;</span><br><span class="line">          transition(CopycatServer.State.INACTIVE);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * Transition handler.</span><br><span class="line">   */</span><br><span class="line">public void transition(CopycatServer.State state) &#123;</span><br><span class="line">    ......</span><br><span class="line">    this.state = createState(state);</span><br><span class="line">    this.state.open().get();</span><br><span class="line">.   .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * Creates an internal state for the given state type.</span><br><span class="line">   */</span><br><span class="line">private AbstractState createState(CopycatServer.State state) &#123;</span><br><span class="line">    switch (state) &#123;</span><br><span class="line">      case INACTIVE:</span><br><span class="line">        return new InactiveState(this);</span><br><span class="line">      case RESERVE:</span><br><span class="line">        return new ReserveState(this);</span><br><span class="line">      case PASSIVE:</span><br><span class="line">        return new PassiveState(this);</span><br><span class="line">      case FOLLOWER:</span><br><span class="line">        return new FollowerState(this);</span><br><span class="line">      case CANDIDATE:</span><br><span class="line">        return new CandidateState(this);</span><br><span class="line">      case LEADER:</span><br><span class="line">        return new LeaderState(this);</span><br><span class="line">      default:</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ACTIVE类型下对应FOLLOWER的状态，通过createState()创建了FollowerState对象，然后调用FollowerState对象的open()方法。FollowerState会调用sendPollRequest()方法去集群上检查所有成员的状态，并决定该CopycatServer是否切换到Candidate角色。</p>
<p>此时集群还没有其它的成员，第一个CopycatServer将自动切换到Candidata角色，调用context.transition(CopycatServer.State.CANDIDATE)方法。</p>
<p>通过transition(CANDIDATE)生成了CandidataState对象，再通过open()调用sendVoteRequests()方法发起投票。<br>该候选人会先把自己的任期号term加1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// When the election timer is reset, increment the current term and restart the election.</span><br><span class="line">context.setTerm(context.getTerm() + 1).setLastVotedFor(context.getCluster().member().id());</span><br></pre></td></tr></table></figure></p>
<p>如果集群还没有其它成员，则该候选人自动成为leader。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// If there are no other members in the cluster, immediately transition to leader.</span><br><span class="line">if (votingMembers.isEmpty()) &#123;</span><br><span class="line">  LOGGER.trace(&quot;&#123;&#125; - Single member cluster. Transitioning directly to leader.&quot;, context.getCluster().member().address());</span><br><span class="line">  context.transition(CopycatServer.State.LEADER);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果集群里有其它成员，则向集群所有成员发送投票请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Send vote requests to all nodes. The vote request that is sent</span><br><span class="line">// to this node will be automatically successful.</span><br><span class="line">// First check if the quorum is null. If the quorum isn&apos;t null then that</span><br><span class="line">// indicates that another vote is already going on.</span><br><span class="line">final Quorum quorum = new Quorum(context.getClusterState().getQuorum(), (elected) -&gt; &#123;</span><br><span class="line">  complete.set(true);</span><br><span class="line">  if (elected) &#123;</span><br><span class="line">    context.transition(CopycatServer.State.LEADER);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    context.transition(CopycatServer.State.FOLLOWER);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Once we got the last log term, iterate through each current member</span><br><span class="line">// of the cluster and vote each member for a vote.</span><br><span class="line">for (ServerMember member : votingMembers) &#123;</span><br><span class="line">  LOGGER.debug(&quot;&#123;&#125; - Requesting vote from &#123;&#125; for term &#123;&#125;&quot;, context.getCluster().member().address(), member, context.getTerm());</span><br><span class="line">  VoteRequest request = VoteRequest.builder()</span><br><span class="line">    .withTerm(context.getTerm())</span><br><span class="line">    .withCandidate(context.getCluster().member().id())</span><br><span class="line">    .withLogIndex(lastIndex)</span><br><span class="line">    .withLogTerm(lastTerm)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">  context.getConnections().getConnection(member.serverAddress()).thenAccept(connection -&gt; &#123;</span><br><span class="line">    connection.&lt;VoteRequest, VoteResponse&gt;sendAndReceive(request).whenCompleteAsync((response, error) -&gt; &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;, context.getThreadContext().executor());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个服务节点会监听来自其它节点的请求，通过CopycatServer的start()和listen()方法来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Starts listening the server.</span><br><span class="line">*/</span><br><span class="line">private CompletableFuture&lt;Void&gt; listen() &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = new CompletableFuture&lt;&gt;();</span><br><span class="line">    context.getThreadContext().executor().execute(() -&gt; &#123;</span><br><span class="line">      internalServer.listen(cluster().member().serverAddress(), context::connectServer).whenComplete((internalResult, internalError) -&gt; &#123;</span><br><span class="line">        if (internalError == null) &#123;</span><br><span class="line">          // If the client address is different than the server address, start a separate client server.</span><br><span class="line">          if (clientServer != null) &#123;</span><br><span class="line">            clientServer.listen(cluster().member().clientAddress(), context::connectClient).whenComplete((clientResult, clientError) -&gt; &#123;</span><br><span class="line">              started = true;</span><br><span class="line">              future.complete(null);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            started = true;</span><br><span class="line">            future.complete(null);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          future.completeExceptionally(internalError);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，connectClient是在ServerContext类中定义的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Handles a connection from another server.</span><br><span class="line">*/</span><br><span class="line">public void connectServer(Connection connection) &#123;</span><br><span class="line">    threadContext.checkThread();</span><br><span class="line"></span><br><span class="line">    // Handlers for all request types are registered since requests can be proxied between servers.</span><br><span class="line">    // Note we do not use method references here because the &quot;state&quot; variable changes over time.</span><br><span class="line">    // We have to use lambdas to ensure the request handler points to the current state.</span><br><span class="line">    connection.handler(RegisterRequest.class, (Function&lt;RegisterRequest, CompletableFuture&lt;RegisterResponse&gt;&gt;) request -&gt; state.register(request));</span><br><span class="line">    connection.handler(ConnectRequest.class, (Function&lt;ConnectRequest, CompletableFuture&lt;ConnectResponse&gt;&gt;) request -&gt; state.connect(request, connection));</span><br><span class="line">    connection.handler(KeepAliveRequest.class, (Function&lt;KeepAliveRequest, CompletableFuture&lt;KeepAliveResponse&gt;&gt;) request -&gt; state.keepAlive(request));</span><br><span class="line">    connection.handler(UnregisterRequest.class, (Function&lt;UnregisterRequest, CompletableFuture&lt;UnregisterResponse&gt;&gt;) request -&gt; state.unregister(request));</span><br><span class="line">    connection.handler(ResetRequest.class, (Consumer&lt;ResetRequest&gt;) request -&gt; state.reset(request));</span><br><span class="line">    connection.handler(ConfigureRequest.class, (Function&lt;ConfigureRequest, CompletableFuture&lt;ConfigureResponse&gt;&gt;) request -&gt; state.configure(request));</span><br><span class="line">    connection.handler(InstallRequest.class, (Function&lt;InstallRequest, CompletableFuture&lt;InstallResponse&gt;&gt;) request -&gt; state.install(request));</span><br><span class="line">    connection.handler(JoinRequest.class, (Function&lt;JoinRequest, CompletableFuture&lt;JoinResponse&gt;&gt;) request -&gt; state.join(request));</span><br><span class="line">    connection.handler(ReconfigureRequest.class, (Function&lt;ReconfigureRequest, CompletableFuture&lt;ReconfigureResponse&gt;&gt;) request -&gt; state.reconfigure(request));</span><br><span class="line">    connection.handler(LeaveRequest.class, (Function&lt;LeaveRequest, CompletableFuture&lt;LeaveResponse&gt;&gt;) request -&gt; state.leave(request));</span><br><span class="line">    connection.handler(AppendRequest.class, (Function&lt;AppendRequest, CompletableFuture&lt;AppendResponse&gt;&gt;) request -&gt; state.append(request));</span><br><span class="line">    connection.handler(PollRequest.class, (Function&lt;PollRequest, CompletableFuture&lt;PollResponse&gt;&gt;) request -&gt; state.poll(request));</span><br><span class="line">    connection.handler(VoteRequest.class, (Function&lt;VoteRequest, CompletableFuture&lt;VoteResponse&gt;&gt;) request -&gt; state.vote(request));</span><br><span class="line">    connection.handler(CommandRequest.class, (Function&lt;CommandRequest, CompletableFuture&lt;CommandResponse&gt;&gt;) request -&gt; state.command(request));</span><br><span class="line">    connection.handler(QueryRequest.class, (Function&lt;QueryRequest, CompletableFuture&lt;QueryResponse&gt;&gt;) request -&gt; state.query(request));</span><br><span class="line"></span><br><span class="line">    connection.onClose(stateMachine.executor().context().sessions()::unregisterConnection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>投票请求对于VoteRequest类，会调用ActiveState的vote()方法来处理。ActiveState是FollowerState、CandidateState和LeaderState的超类。对于Follower，并没有重写vote方法，直接调用父类ActiveState的实现来处理。</p>
<p>ActiveState类的vote()方法会继续调用handleVote()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Handles a vote request.</span><br><span class="line">*/</span><br><span class="line">protected VoteResponse handleVote(VoteRequest request) &#123;</span><br><span class="line">    // If the request term is not as great as the current context term then don&apos;t</span><br><span class="line">    // vote for the candidate. We want to vote for candidates that are at least</span><br><span class="line">    // as up to date as us.</span><br><span class="line">    if (request.term() &lt; context.getTerm()) &#123;</span><br><span class="line">      LOGGER.trace(&quot;&#123;&#125; - Rejected &#123;&#125;: candidate&apos;s term is less than the current term&quot;, context.getCluster().member().address(), request);</span><br><span class="line">      return VoteResponse.builder()</span><br><span class="line">        .withStatus(Response.Status.OK)</span><br><span class="line">        .withTerm(context.getTerm())</span><br><span class="line">        .withVoted(false)</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line">    // If a leader was already determined for this term then reject the request.</span><br><span class="line">    else if (context.getLeader() != null) &#123;</span><br><span class="line">      LOGGER.trace(&quot;&#123;&#125; - Rejected &#123;&#125;: leader already exists&quot;, context.getCluster().member().address(), request);</span><br><span class="line">      return VoteResponse.builder()</span><br><span class="line">        .withStatus(Response.Status.OK)</span><br><span class="line">        .withTerm(context.getTerm())</span><br><span class="line">        .withVoted(false)</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line">    // If the requesting candidate is not a known member of the cluster (to this</span><br><span class="line">    // node) then don&apos;t vote for it. Only vote for candidates that we know about.</span><br><span class="line">    else if (!context.getClusterState().getRemoteMemberStates().stream().&lt;Integer&gt;map(m -&gt; m.getMember().id()).collect(Collectors.toSet()).contains(request.candidate())) &#123;</span><br><span class="line">      LOGGER.trace(&quot;&#123;&#125; - Rejected &#123;&#125;: candidate is not known to the local member&quot;, context.getCluster().member().address(), request);</span><br><span class="line">      return VoteResponse.builder()</span><br><span class="line">        .withStatus(Response.Status.OK)</span><br><span class="line">        .withTerm(context.getTerm())</span><br><span class="line">        .withVoted(false)</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line">    // If no vote has been cast, check the log and cast a vote if necessary.</span><br><span class="line">    else if (context.getLastVotedFor() == 0) &#123;</span><br><span class="line">      if (isLogUpToDate(request.logIndex(), request.logTerm(), request)) &#123;</span><br><span class="line">        context.setLastVotedFor(request.candidate());</span><br><span class="line">        return VoteResponse.builder()</span><br><span class="line">          .withStatus(Response.Status.OK)</span><br><span class="line">          .withTerm(context.getTerm())</span><br><span class="line">          .withVoted(true)</span><br><span class="line">          .build();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return VoteResponse.builder()</span><br><span class="line">          .withStatus(Response.Status.OK)</span><br><span class="line">          .withTerm(context.getTerm())</span><br><span class="line">          .withVoted(false)</span><br><span class="line">          .build();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // If we already voted for the requesting server, respond successfully.</span><br><span class="line">    else if (context.getLastVotedFor() == request.candidate()) &#123;</span><br><span class="line">      LOGGER.debug(&quot;&#123;&#125; - Accepted &#123;&#125;: already voted for &#123;&#125;&quot;, context.getCluster().member().address(), request, context.getCluster().member(context.getLastVotedFor()).address());</span><br><span class="line">      return VoteResponse.builder()</span><br><span class="line">        .withStatus(Response.Status.OK)</span><br><span class="line">        .withTerm(context.getTerm())</span><br><span class="line">        .withVoted(true)</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line">    // In this case, we&apos;ve already voted for someone else.</span><br><span class="line">    else &#123;</span><br><span class="line">      LOGGER.debug(&quot;&#123;&#125; - Rejected &#123;&#125;: already voted for &#123;&#125;&quot;, context.getCluster().member().address(), request, context.getCluster().member(context.getLastVotedFor()).address());</span><br><span class="line">      return VoteResponse.builder()</span><br><span class="line">        .withStatus(Response.Status.OK)</span><br><span class="line">        .withTerm(context.getTerm())</span><br><span class="line">        .withVoted(false)</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果该候选人赢得了选举，则通过context.transition(CopycatServer.State.LEADER)成为领导者，否则继续回退到FOLLOWER角色。</p>
<p>当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。</p>
<p>在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项RPC。如果这个领导人的任期号（包含在此次的RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。如果此次RPC中的任期号比自己小，那么候选人就会拒绝这次的RPC并且继续保持候选人状态。</p>
<p>有一种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</p>
<p>Raft算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。</p>
<p>当候选人成为领导者时，会创建LeaderState实例，并调用open方法，写入InitializeEntry日志，然后调用context.getStateMachine().apply(resultIndex)在状态机中应用该状态。最后通过startAppendTimer()循环调用LeaderAppender类的appendMembers()方法，告诉其它节点“我是领导者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void appendEntries(MemberState member) &#123;</span><br><span class="line">    // Prevent recursive, asynchronous appends from being executed if the appender has been closed.</span><br><span class="line">    if (!open)</span><br><span class="line">      return;</span><br><span class="line"></span><br><span class="line">    // If prior requests to the member have failed, build an empty append request to send to the member</span><br><span class="line">    // to prevent having to read from disk to configure, install, or append to an unavailable member.</span><br><span class="line">    if (member.getFailureCount() &gt;= MINIMUM_BACKOFF_FAILURE_COUNT) &#123;</span><br><span class="line">      // To prevent the leader from unnecessarily attempting to connect to a down follower on every heartbeat,</span><br><span class="line">      // use exponential backoff to back off up to 60 second heartbeat intervals.</span><br><span class="line">      if (System.currentTimeMillis() - member.getHeartbeatStartTime() &gt; Math.min(heartbeatInterval * Math.pow(2, member.getFailureCount()), MAX_HEARTBEAT_WAIT)) &#123;</span><br><span class="line">        sendAppendRequest(member, buildAppendEmptyRequest(member));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // If the member term is less than the current term or the member&apos;s configuration index is less</span><br><span class="line">    // than the local configuration index, send a configuration update to the member.</span><br><span class="line">    // Ensure that only one configuration attempt per member is attempted at any given time by storing the</span><br><span class="line">    // member state in a set of configuring members.</span><br><span class="line">    // Once the configuration is complete sendAppendRequest will be called recursively.</span><br><span class="line">    else if (member.getConfigTerm() &lt; context.getTerm() || member.getConfigIndex() &lt; context.getClusterState().getConfiguration().index()) &#123;</span><br><span class="line">      if (member.canConfigure()) &#123;</span><br><span class="line">        sendConfigureRequest(member, buildConfigureRequest(member));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // If the member is a reserve or passive member, send an empty AppendRequest to it.</span><br><span class="line">    else if (member.getMember().type() == Member.Type.RESERVE || member.getMember().type() == Member.Type.PASSIVE) &#123;</span><br><span class="line">      if (member.canAppend()) &#123;</span><br><span class="line">        sendAppendRequest(member, buildAppendEmptyRequest(member));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // If the member&apos;s current snapshot index is less than the latest snapshot index and the latest snapshot index</span><br><span class="line">    // is less than the nextIndex, send a snapshot request.</span><br><span class="line">    else if (member.getMember().type() == Member.Type.ACTIVE &amp;&amp; context.getSnapshotStore().currentSnapshot() != null</span><br><span class="line">      &amp;&amp; context.getSnapshotStore().currentSnapshot().index() &gt;= member.getNextIndex()</span><br><span class="line">      &amp;&amp; context.getSnapshotStore().currentSnapshot().index() &gt; member.getSnapshotIndex()) &#123;</span><br><span class="line">      if (member.canInstall()) &#123;</span><br><span class="line">        sendInstallRequest(member, buildInstallRequest(member));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // If no AppendRequest is already being sent, send an AppendRequest.</span><br><span class="line">    else if (member.canAppend()) &#123;</span><br><span class="line">      sendAppendRequest(member, buildAppendRequest(member, context.getLog().lastIndex()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>其它节点收到消息后，则以Follower身份不断接收Leader的消息，进行日志同步复制，Copycat的领导者选举过程到此结束。</p>
<p>关于raft算法的更多细节，可以参考 <a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</a> 这篇文章。</p>
<p>后面再分析日志同步和日志压缩过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      

    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/CentOS-7离线安装Kubernetes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Rui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TechLiving">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/CentOS-7离线安装Kubernetes/" itemprop="url">CentOS-7离线安装Kubernetes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-16T11:00:00+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/16/CentOS-7离线安装Kubernetes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/16/CentOS-7离线安装Kubernetes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本机上搭完了minikube环境，跑了几个k8s的例子，还是不满足，想在集群环境下搭建k8s，进一步学习。可是服务器是内网环境，不能用yum连接外网自动安装。  </p>
<p>一开始根据网上教程，在<a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.10.md#downloads-for-v1104" target="_blank" rel="noopener">github</a>下载了最新稳定版1.10.4的kubenetes服务端安装包，主要是kubeadm、kubelet、kubectl等命令，不需要其它的软件依赖。kubeadm是初始化集群master的管理工具，可能通过kubeadm init快速建立master。kubelet是调度k8s任务和监控集群状态的工具。kubectl是与集群交互的命令行工具。  </p>
<p>还要下载etcd的二进制程序后，在服务器上执行kubeadm init，直接提示获取最新k8s版本信息失败。  </p>
<p>原来kubeadm运行参数中没有指定k8s版本时，会自动联网获取最新版本信息。而服务器是不能连外网的，需要指定–kubernetes-version:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16 --kubernetes-version v1.10.0</span><br></pre></td></tr></table></figure></p>
<p>本地肯定也要下载v1.10.0版本的依赖镜像。按照<a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.10.md#downloads-for-v1104" target="_blank" rel="noopener">github</a>的指导，下载如下镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/kube-proxy-amd64                v1.10.0             bfc21aadc7d3        2 months ago        97MB</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64   v1.10.0             ad86dbed1555        2 months ago        148MB</span><br><span class="line">k8s.gcr.io/kube-apiserver-amd64            v1.10.0             af20925d51a3        2 months ago        225MB</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64            v1.10.0             704ba848e69a        2 months ago        50.4MB</span><br><span class="line">weaveworks/weave-npc                       2.2.1               26d868a4eb75        3 months ago        46.6MB</span><br><span class="line">weaveworks/weave-kube                      2.2.1               86e2da7dd27b        3 months ago        93.8MB</span><br><span class="line">k8s.gcr.io/etcd-amd64                      3.1.12              52920ad46f5b        3 months ago        193MB</span><br><span class="line">k8s.gcr.io/kubernetes-dashboard-amd64      v1.8.3              0c60bcf89900        4 months ago        102MB</span><br><span class="line">k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64     1.14.8              c2ce1ffb51ed        5 months ago        41MB</span><br><span class="line">k8s.gcr.io/k8s-dns-sidecar-amd64           1.14.8              6f7f2dc7fab5        5 months ago        42.2MB</span><br><span class="line">k8s.gcr.io/k8s-dns-kube-dns-amd64          1.14.8              80cc5ea4b547        5 months ago        50.5MB</span><br><span class="line">k8s.gcr.io/pause-amd64                     3.1                 da86e6ba6ca1        5 months ago        742kB</span><br><span class="line">quay.io/coreos/flannel                     v0.10.0-amd64</span><br><span class="line">f0fad859c909        4 months ago        44.6MB</span><br><span class="line">quay.io/kubernetes-ingress-controller/nginx-ingress-controller      0.15.0</span><br><span class="line">c46bc3e1b53c        5 weeks ago         265MB</span><br><span class="line">gcr.io/google_containers/defaultbackend               1.4</span><br><span class="line">846921f0fe0e        7 months ago        4.84MB</span><br></pre></td></tr></table></figure></p>
<p>具体方法是，登录本地的minikube:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">minikube ssh</span><br><span class="line">docker pull k8s.gcr.io/kube-proxy-amd64:v1.10.0</span><br><span class="line">docker pull k8s.gcr.io/kube-controller-manager-amd64:v1.10.0</span><br><span class="line">docker pull k8s.gcr.io/kube-apiserver-amd64:v1.10.0</span><br><span class="line">docker pull k8s.gcr.io/kube-scheduler-amd64:v1.10.0</span><br><span class="line">docker pull weaveworks/weave-npc:2.2.1 </span><br><span class="line">docker pull weaveworks/weave-kube:2.2.1</span><br><span class="line">docker pull k8s.gcr.io/etcd-amd64:3.1.12</span><br><span class="line">docker pull k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.3</span><br><span class="line">docker pull k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64:1.14.8</span><br><span class="line">docker pull k8s.gcr.io/k8s-dns-sidecar-amd64:1.14.8</span><br><span class="line">docker pull k8s.gcr.io/k8s-dns-kube-dns-amd64:1.14.8 </span><br><span class="line">docker pull k8s.gcr.io/pause-amd64:3.1</span><br><span class="line">docker pull quay.io/coreos/flannel:v0.10.0-amd64</span><br><span class="line">docker pull quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.15.0</span><br><span class="line">docker pull gcr.io/google_containers/defaultbackend:1.4</span><br></pre></td></tr></table></figure></p>
<p>因为需要翻墙，需要配置minikube的shadowsoks代理。有两种代理方式：1、命令行代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minikube start --docker-env=HTTP_PROXY=http://192.168.99.1:1087 \</span><br><span class="line">               --docker-env=HTTPS_PROXY=https://192.168.99.1:1087</span><br></pre></td></tr></table></figure></p>
<p>2、编辑 ~/.minikube/machines/minikube/config.json中的HostOptions.EngineOptions.Env配置，加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;Env&quot;: [                                       </span><br><span class="line">    &quot;HTTP_PROXY=http://192.168.99.1:1087&quot;,</span><br><span class="line">    &quot;HTTPS_PROXY=http://192.168.99.1:1087&quot;,</span><br><span class="line">    &quot;NO_PROXY=192.168.99.100/24&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>说明一下，minikube虚拟环境的IP默认是192.168.99.100，宿主机（也是本地电脑）的IP默认是192.168.99.1，所以需要设置ss代理。  </p>
<p>minikube环境里的docker全部pull完毕后，再依次执行docker save。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save k8s.gcr.io/kube-proxy-amd64:v1.10.0 &gt; kube-proxy-amd64</span><br></pre></td></tr></table></figure></p>
<p>全部导出来后打包成k8s.tar.gz。  </p>
<p>还要从minikube里导出到本地电脑磁盘上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -i $(minikube ssh-key) docker@$(minikube ip):/home/docker/k8s.tar.gz k8s.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>然后上传到服务器上，依次执行docker load:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; kube-proxy-amd64</span><br></pre></td></tr></table></figure></p>
<p>用docker images查看镜像，如果出现REPOSITORY和TAG为none，重新打一下标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag ad86dbed1555 k8s.gcr.io/kube-controller-manager-amd64:v1.10.0</span><br></pre></td></tr></table></figure></p>
<p>如果服务器上还没有安装docker程序，可以在本地用createrepo构造docker的yum安装依赖包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 服务器上查看centos版本</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line"># 然后本地构建相同版本的centos系统</span><br><span class="line">docker pull centos:7.2.1511</span><br><span class="line"># 查看image id</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"># 进入centos环境</span><br><span class="line">docker run -ti &lt;IMAGE ID&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"># 下载yum依赖包</span><br><span class="line">yum -y install yum-utils</span><br><span class="line">repotrack -a x86_64 -p yum/local createrepo</span><br><span class="line">repotrack -a x86_64 -p yum/local libgudev1</span><br><span class="line">repotrack -a x86_64 -p yum/local systemd-sysv</span><br><span class="line">repotrack -a x86_64 -p yum/local dracut-network</span><br><span class="line">repotrack -a x86_64 -p yum/local dracut-config-rescue</span><br><span class="line">repotrack -a x86_64 -p yum/local systemd-python</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">repotrack -a x86_64 -p yum/local docker-ce</span><br><span class="line"></span><br><span class="line">tar czvf centos7-docker-yum.gz yum</span><br><span class="line"></span><br><span class="line"># 本地电脑执行docker ps，查看container id</span><br><span class="line">docker cp &lt;CONTAINER ID&gt;:/root/centos7-docker-yum.gz .</span><br></pre></td></tr></table></figure></p>
<p>把所有依赖包导出来，然后上传服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf centos7-docker-yum.gz</span><br><span class="line"></span><br><span class="line">vi /etc/yum.repos.d/CentOS-Local.repo</span><br><span class="line">[Local]</span><br><span class="line">name=Local Yum</span><br><span class="line">baseurl=file:///root/yum/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">createrepo /root/yum</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line">yum -y install docker-ce</span><br><span class="line"></span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure></p>
<p>这样服务器就离线安装好docker了。  </p>
<p>k8s镜像准备好后，再次执行 kubeadm init –pod-network-cidr=10.244.0.0/16  –kubernetes-version v1.10.0， 发现还是卡住了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[init] This might take a minute or longer if the control plane images have to be pulled.</span><br></pre></td></tr></table></figure></p>
<p>查看tail -f /var/log/messages，发现一直输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubelet_node_status.go:271] Setting node annotation to enable volume controller attach/detach</span><br></pre></td></tr></table></figure></p>
<p>网上怎么查资料，都找不到解决办法。  </p>
<p>网上也有人打包好了k8s所有的安装包和镜像，并做成了shell脚本自动化安装，售价50元。本着程序员爱折腾不服气的精神，继续想办法。  </p>
<p>看到有人用yum安装kubelet、kubeadm和kubectl，突然想到也可以本地用docker构建yum依赖包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 服务器上查看centos版本</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line"># 然后本地构建相同的centos系统</span><br><span class="line">docker pull centos:7.2.1511</span><br><span class="line"></span><br><span class="line"># 查看image id</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"># 进入centos环境</span><br><span class="line">docker run -ti &lt;IMAGE ID&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"># 下载依赖包</span><br><span class="line">repotrack -a x86_64 -p k8s kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line">或者 yum -y install --downloadonly --downloaddir=k8s kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure></p>
<p>从docker里导出来，上传到服务器。并在服务器上重新构建yum本地仓库，然后安装yum install -y kubelet kubeadm kubectl。(具体步骤见文中离线安装docker部分)  </p>
<p>安装完成后，生成kubelet的systemctl脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure></p>
<p>此时不要systemctl start kubelet，肯定会失败，还需要修改默认配置。  </p>
<p>编辑/etc/systemd/system/kubelet.service.d/10-kubeadm.conf。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;KUBELET_CGROUP_ARGS=--cgroup-driver=cgroupfs&quot;</span><br></pre></td></tr></table></figure></p>
<p>把cgroup-drive改成cgroupfs，跟docker的cgroup保持一致。  </p>
<p>以上全部准备好后，再次执行 kubeadm init –pod-network-cidr=10.244.0.0/16  –kubernetes-version v1.10.0，总算看到成功信息了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># kubeadm init --pod-network-cidr=10.244.0.0/16  --kubernetes-version v1.10.0 </span><br><span class="line"></span><br><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join 10.95.134.84:6443 --token 6h86uf.w4fybn0usz2e8etm --discovery-token-ca-cert-hash sha256:91be4a5060fcdd7d4a8bf7de7b468154401cce4b5dfd0d6aba6ec23a6e36000e</span><br></pre></td></tr></table></figure></p>
<p>master就算安装成功了，接下来安装cluster。  </p>
<p>注意，增加–pod-network-cidr参数，如果不使用，则flannel pod启动后会出现“failed to register network: failed to acquire lease: node “xxxxxx” pod cidr not assigned”错误。  </p>
<p>同样在其它cluster服务器上用yum本地安装kubelet、kubeadm、kubectl，并编辑好/etc/systemd/system/kubelet.service.d/10-kubeadm.conf。</p>
<p>然后执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.0.4:6443 --token 6h86uf.w4fybn0usz2e8etm --discovery-token-ca-cert-hash sha256:91be4a5060fcdd7d4a8bf7de7b468154401cce4b5dfd0d6aba6ec23a6e36000e</span><br></pre></td></tr></table></figure></p>
<p>会提示加入到cluster成功。  </p>
<p>然后把master机器上的/etc/kubernetes/admin.conf传到cluster机器上，并在cluster上执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure></p>
<p>这样就可以在cluster上也查看pods、services等状态了。  </p>
<p>在master或cluster机器上执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure></p>
<p>看到如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                   STATUS    ROLES     AGE       VERSION</span><br><span class="line">server01               Ready     &lt;none&gt;    9h        v1.10.4</span><br><span class="line">server02               Ready     master    9h        v1.10.4</span><br><span class="line">server03               Ready     &lt;none&gt;    8h        v1.10.4</span><br></pre></td></tr></table></figure></p>
<p>注意，cluster节点上也需要本地导入依赖镜像，否则master上部署服务时，cluster会因为没有依赖镜像而尝试从网络下载。  </p>
<p>安装flannel服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure></p>
<p>安装dashboard：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure></p>
<p>安装ingress-nginx服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml</span><br></pre></td></tr></table></figure></p>
<p>注意，服务器不能联网，可以将kube-flannel.yml、kubernetes-dashboard.yaml、mandatory.yaml三个配置文件下载到本地，再上传到服务器进行本地安装。  </p>
<p>最终查看pods状态如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@bd04 xxxx]# kubectl get pods --all-namespaces</span><br><span class="line">NAMESPACE       NAME                                           READY     STATUS    RESTARTS   AGE</span><br><span class="line">ingress-nginx   default-http-backend-5c6d95c48-tblk9           1/1       Running   0          9h</span><br><span class="line">ingress-nginx   nginx-ingress-controller-58c9df5856-sjs79      1/1       Running   0          9h</span><br><span class="line">kube-system     etcd-server04                                  1/1       Running   6          1d</span><br><span class="line">kube-system     kube-apiserver-server04                        1/1       Running   6          1d</span><br><span class="line">kube-system     kube-controller-manager-server04               1/1       Running   0          10h</span><br><span class="line">kube-system     kube-dns-86f4d74b45-5vczm                      3/3       Running   3          1d</span><br><span class="line">kube-system     kube-flannel-ds-gthqp                          1/1       Running   24         11h</span><br><span class="line">kube-system     kube-flannel-ds-kdgw8                          1/1       Running   18         11h</span><br><span class="line">kube-system     kube-flannel-ds-pq79j                          1/1       Running   13         11h</span><br><span class="line">kube-system     kube-proxy-5qgfb                               1/1       Running   0          6d</span><br><span class="line">kube-system     kube-proxy-jp74t                               1/1       Running   0          6d</span><br><span class="line">kube-system     kube-proxy-wpn9k                               1/1       Running   6          6d</span><br><span class="line">kube-system     kube-scheduler-server04                        1/1       Running   7          1d</span><br><span class="line">kube-system     kubernetes-dashboard-7d5dcdb6d9-gvrg9          1/1       Running   0          7s</span><br></pre></td></tr></table></figure></p>
<p>k8s集群环境搭建完毕！  </p>
<p>k8s的环境搭建确实很麻烦，即使服务器有网络环境，也需要翻墙软件，才能自动docker下载。也有教程指导从国内阿里云等下载镜像，用docker tag重新打标签，后面再尝试。  </p>
<p>对于一个全新的技术框架，亲自动手搭建环境，跑demo是第一步，后面继续折腾吧。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      

    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/17/Sleuth-Kafka-Zipkin-ElasticSearch链路追踪/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Rui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TechLiving">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/17/Sleuth-Kafka-Zipkin-ElasticSearch链路追踪/" itemprop="url">Sleuth+Kafka+Zipkin+ElasticSearch链路追踪</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-17T16:36:56+08:00">
                2018-05-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/17/Sleuth-Kafka-Zipkin-ElasticSearch链路追踪/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/05/17/Sleuth-Kafka-Zipkin-ElasticSearch链路追踪/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Zipkin是来自Twitter的开源分布式追踪系统，它可以应用于微服务架构的系统里，收集各个服务环节的响应时间等数据，方便定位系统故障和问题。</p>
<p>Zipkin的系统架构图如下：<br><img src="/2018/05/17/Sleuth-Kafka-Zipkin-ElasticSearch链路追踪/zipkin-architecture.png" alt=""></p>
<center>图一 Zipkin架构</center>

<p>从架构图上可以看出，zipkin主要用于接收数据(Collector)，存储(Storage)，检索(API)并展示(UI)。Zipkin本身并不会直接在分布式系统里trace数据，是由<a href="https://github.com/openzipkin/brave" target="_blank" rel="noopener">brave</a>组件来完成的。</p>
<p>Brave使用起来不是很方便，编码量有些大，而利用Spring Cloud的sleuth组件可以很方便地和zipkin整合，将trace数据通过http，Kafka或rabbitmq发送给zipkin。</p>
<p>Sleuth也是一套分布式追踪组件，但它本身只支持内存存储，也没有web UI展示tracing图，所以需要和zipkin结合起来使用。</p>
<p>引用spring-cloud-starter-zipkin组件，只需要简单配置，就可以方便使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>从spring-cloud-starter-zipkin的pom.xml文件里可以看到它自动引用了spring-cloud-starter-sleuth和spring-cloud-sleuth-zipkin。</p>
<p>只要在application.yml里配置spring.zipkin.base-url并指定zipkin的服务接口地址，sleuth即可自动追踪所有的Restful请求，并默认通过http传给zipkin。</p>
<p>在业务量大的情况下，http的传输效率可能会影响业务系统的性能，所以可以换成rabbitmq或kafka来传输trace数据。Spring Cloud Dalston或更低版本，是通过spring-cloud-sleuth-zipkin-stream插件来完成的，但从Edgware及更高版本，已经简化了操作，只需要引入<a href="https://cloud.spring.io/spring-cloud-sleuth/single/spring-cloud-sleuth.html#_sleuth_with_zipkin_over_rabbitmq_or_kafka" target="_blank" rel="noopener">spring-rabbitmq或spring-kafka</a>即可。</p>
<p>网上有很多sleuth通过rabbitmq传输给zipkin的例子和教程，但很少看到通过kafka传输的，Spring Cloud Sleuth官网也只给介绍了如何引用jar，没有给出参数配置示例，下面结合demo给出参考配置。</p>
<p>在Restful服务的项目的application.yml里配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  zipkin:</span><br><span class="line">    base-url: http://localhost:9411</span><br><span class="line">    kafka:</span><br><span class="line">      topic: zipkin</span><br><span class="line">  kafka:</span><br><span class="line">    bootstrap-servers: localhost:9092</span><br><span class="line"></span><br><span class="line">  sleuth:</span><br><span class="line">    sampler:</span><br><span class="line">      percentage: 1.0</span><br></pre></td></tr></table></figure></p>
<p>然后在zipkin server项目的application.yml里配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">zipkin:</span><br><span class="line">  storage:</span><br><span class="line">    type: elasticsearch</span><br><span class="line">    elasticsearch:</span><br><span class="line">      hosts: localhost:9300</span><br><span class="line">      index: zipkin</span><br><span class="line"></span><br><span class="line">  collector:</span><br><span class="line">    kafka:</span><br><span class="line">      zookeeper: localhost:2181</span><br><span class="line">      topic: zipkin</span><br><span class="line">      groupId: zipkin</span><br></pre></td></tr></table></figure></p>
<p>下面分析一下Spring Boot和Spring Cloud的starter启动器加载上述配置项的过程。</p>
<p>前面提到了，项目引入了spring-cloud-starter-zipkin，实际上Spring Boot项目的starter启动器都只是单纯的pom.xml依赖引用，并没有具体的代码实现。spring-cloud-starter-zipkin的pom.xml引入了spring-cloud-starter-sleuth和spring-cloud-sleuth-zipkin，前者也是一个starter，后者有具体的代码实现。</p>
<p>spring-cloud-sleuth-zipkin的源码实现比较简单，直接看ZipkinAutoConfiguration类，它又开启了ZipkinProperties的配置，同时还引入了ZipkinSenderConfigurationImportSelector类。</p>
<p>ZipkinProperties类有注解@ConfigurationProperties(“spring.zipkin”)，还有baseUrl等属性，正好对应了前面application.yml里的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  zipkin:</span><br><span class="line">    base-url: http://localhost:9411</span><br></pre></td></tr></table></figure></p>
<p>baseUrl本身有默认值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private String baseUrl = &quot;http://localhost:9411/&quot;;</span><br></pre></td></tr></table></figure></p>
<p>所以，如果后端的zipkin server地址是本机的9411端口，application.yml里就可以不配置了。</p>
<p>ZipkinSenderConfigurationImportSelector类会根据classpath里kafka或rabbitmq的引用，来决定采用哪种传输方式。我们在项目里引用了spring-kafka，对应到ZipkinKafkaSenderConfiguration类，这个类仅仅读取spring.zipkin.kafka.topic配置，并且默认的topic为zipkin，也就是前面application.yml里配置的。</p>
<h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>ZipkinSenderConfigurationImportSelector是如何被Spring Boot框架调用的？</p>
<p>在idea里调用Call Hierarchy可以看到方法调用链：<br><img src="/2018/05/17/Sleuth-Kafka-Zipkin-ElasticSearch链路追踪/ImportSelector.jpeg" alt=""></p>
<center>图二 ZipkinSenderConfigurationImportSelector调用关系</center>

<p>最上层的方法是AbstractApplicationContext.refresh()，这个方法在SpringApplication类里。Spring Boot的启动方法是SpringApplication.run(App.class, args)，通过下面的方法调用，到达了((AbstractApplicationContext) applicationContext).refresh()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    //...</span><br><span class="line">    try &#123;</span><br><span class="line">        //...</span><br><span class="line">        refreshContext(context);</span><br><span class="line">        // ...</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">        throw new IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void refreshContext(ConfigurableApplicationContext context) &#123;</span><br><span class="line">    refresh(context);</span><br><span class="line">    if (this.registerShutdownHook) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (AccessControlException ex) &#123;</span><br><span class="line">            // Not allowed in some environments.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Refresh the underlying &#123;@link ApplicationContext&#125;.</span><br><span class="line"> * @param applicationContext the application context to refresh</span><br><span class="line"> */</span><br><span class="line">protected void refresh(ApplicationContext applicationContext) &#123;</span><br><span class="line">    Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">    ((AbstractApplicationContext) applicationContext).refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>框架里有很多个ImportSelector，Spring Boot是如何找到ZipkinSenderConfigurationImportSelector并调用selectImports()方法的呢？</p>
<p>看ZipkinAutoConfiguration类有@Configuration注解，图二调用链中的.processConfigBeanDefinitions(BeanDefinitionRegistry)方法，看该方法的注释，正是这个方法把所有Configuration的类全部进行构造和初始化。而ZipkinAutoConfiguration类同时包括@Configuration和@Import(ZipkinSenderConfigurationImportSelector.class)的注解，因此Spring Boot通过@Configuration找到了所有的ImportSelector实现类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//------------------------------------</span><br><span class="line">ConfigurationClassPostProcessor.class</span><br><span class="line">//------------------------------------</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Build and validate a configuration model based on the registry of</span><br><span class="line"> * &#123;@link Configuration&#125; classes.</span><br><span class="line"> */</span><br><span class="line">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void processDeferredImportSelectors() &#123;</span><br><span class="line">    // ...</span><br><span class="line">    String[] imports = deferredImport.getImportSelector().selectImports(configClass.getMetadata());</span><br><span class="line">    processImports(configClass, asSourceClass(configClass), asSourceClasses(imports), false);</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//------------------------------------</span><br><span class="line">AutoConfigurationImportSelector.class</span><br><span class="line">//------------------------------------</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">            attributes);</span><br><span class="line">    // ...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Return the auto-configuration class names that should be considered. By default</span><br><span class="line"> * this method will load candidates using &#123;@link SpringFactoriesLoader&#125; with</span><br><span class="line"> * &#123;@link #getSpringFactoriesLoaderFactoryClass()&#125;.</span><br><span class="line"> * @param metadata the source metadata</span><br><span class="line"> * @param attributes the &#123;@link #getAttributes(AnnotationMetadata) annotation</span><br><span class="line"> * attributes&#125;</span><br><span class="line"> * @return a list of candidate configurations</span><br><span class="line"> */</span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,</span><br><span class="line">        AnnotationAttributes attributes) &#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">    // ...</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">    List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The location to look for factories.</span><br><span class="line"> * &lt;p&gt;Can be present in multiple JAR files.</span><br><span class="line"> */</span><br><span class="line">public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</span><br></pre></td></tr></table></figure></p>
<p>loadFactoryNames()方法会加载classpath环境中所有包含了META-INF/spring.factories的jar包，包括spring-boot-context，spring-cloud-context，spring-cloud-sleuth-coure，spring-cloud-sleuth-zipkin，其中spring-cloud-sleuth-zipkin包的META-INF/spring.factories定义了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configuration</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.cloud.sleuth.zipkin2.ZipkinAutoConfiguration</span><br></pre></td></tr></table></figure></p>
<p>最终加载了ZipkinAutoConfiguration类。</p>
<p>项目里还自动引用了spring-boot-autoconfigure，在KafkaProperties类里，自动将<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  kafka:</span><br><span class="line">    bootstrap-servers: localhost:9092</span><br></pre></td></tr></table></figure></p>
<p>注入进来，ZipkinKafkaSenderConfiguration在构建kafkaSender()方法时会使用该配置。</p>
<p>Zipkin server端的kafka配置，需要看zipkin-autoconfigure-collector-kafka的ZipkinKafkaCollectorProperties类源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zipkin:</span><br><span class="line">  collector:</span><br><span class="line">    kafka:</span><br><span class="line">      zookeeper: localhost:2181</span><br><span class="line">      topic: zipkin</span><br><span class="line">      groupId: zipkin</span><br></pre></td></tr></table></figure></p>
<p>而zipkin配置ElasticSearch存储，看zipkin-autoconfigure-storage-elasticsearch-http的 ZipkinElasticsearchHttpStorageProperties类源码。</p>
<p>通过分析源码包里的代码，可以准确指导我们该如何正确的配置，这个方法比在网上到处找资料要效率多了。</p>
<p>附上<a href="https://github.com/liaorui/zipkin-demo" target="_blank" rel="noopener">demo源码</a>，更接地气。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      

    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/23/Prepare-statement防止SQL注入/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Rui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TechLiving">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/23/Prepare-statement防止SQL注入/" itemprop="url">PreparedStatement防止SQL注入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-23T17:25:14+08:00">
                2018-04-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/23/Prepare-statement防止SQL注入/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/04/23/Prepare-statement防止SQL注入/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一般在程序里写SQL查询时，为了省事，往往喜欢把SQL语句和变量拼在一起，用字符串连起来。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;User&gt; getUser(String name)&#123;</span><br><span class="line">    String sql = &quot;select * from user_tbl where name = &apos;&quot; + name + &quot;&apos;&quot;;</span><br><span class="line">    return queryForList(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，name是变量，从前端页面传过来的，这里容易发生SQL注入攻击。假如前端页面被恶意截获，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; or &apos;1&apos;=&apos;1</span><br></pre></td></tr></table></figure></p>
<p> ，那么上述的sql经过拼接后就变成了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;select * from user_tbl where name = &apos;&apos; or &apos;1&apos;=&apos;1&apos;&quot;;</span><br></pre></td></tr></table></figure></p>
<p>由于or表达式为真，相当于用户表里所有的用户记录都满足where条件，会把用户表里所有的记录查出来。</p>
<p>再恶意的攻击是输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;; drop table user_tbl; --</span><br></pre></td></tr></table></figure></p>
<p>，直接删除用户表。其中，分号表示后面接新的SQL语句，而双横杠表示SQL注释，很可能被利用起来忽略掉正确的where过滤条件。因此，后端对SQL查询参数，一定要过滤单引号，分号和双横杠。</p>
<p>JDBC里，可以用PreparedStatement预编译结合问号(?)来避免SQL注入，用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;User&gt; getUser(String name) &#123;</span><br><span class="line">    String sql = &quot;select * from user_tbl where name = ?&quot;;</span><br><span class="line">    PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">    ps.setString(1, name);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，为什么PreparedStatement可以解决SQL注入问题呢？</p>
<p>从上面分析可以知道，单引号、分号和双横杠在SQL语句中有特殊含义，输入参数需要转义这几个字符，避免产生副作用，因此猜测JDBC也是这样干的。</p>
<p>跟踪代码，可以看到Connection和PreparedStatement都是接口，转义操作不会在Java JDBC API里，那么应该是各个数据库厂商自己提供的JDBC driver里做了。</p>
<p>下面以PostgreSQL为例，追踪一下代码，maven中引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;postgresql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;9.1-901-1.jdbc4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>在下面两行代码里加断点调试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setString(1, name);</span><br></pre></td></tr></table></figure></p>
<p>简单的两行代码，PostgreSQL driver干了很多事情，跟了很多遍，才找到如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">org.postgresql.core.v3.SimpleParameterList</span><br><span class="line"></span><br><span class="line">int getV3Length(int index) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // Already encoded?</span><br><span class="line">    if (encoded[index] == null)</span><br><span class="line">    &#123;</span><br><span class="line">        // Encode value and compute actual length using UTF-8.</span><br><span class="line">        encoded[index] = Utils.encodeUTF8(paramValues[index].toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return encoded[index].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void writeV3Value(int index, PGStream pgStream) throws IOException &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // Encoded string.</span><br><span class="line">    if (encoded[index] == null)</span><br><span class="line">        encoded[index] = Utils.encodeUTF8((String)paramValues[index]);</span><br><span class="line">    pgStream.Send(encoded[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void Send(byte buf[]) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    pg_output.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于paramValues数组存了SQL输入参数，对比getV3Length()和writeV3Value()，输入参数其实并没有变化，最终pgStream.Send(encoded[index])直接通过Socket原样发给PostgerSQL Server了。</p>
<p>encodeUTF8()实现也很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] encodeUTF8(String str) &#123;</span><br><span class="line">        // Previously we just used str.getBytes(&quot;UTF-8&quot;), but when</span><br><span class="line">        // the JVM is using more than one encoding the lookup cost</span><br><span class="line">        // makes that a loser to the below (even in the single thread case).</span><br><span class="line">        // When multiple threads are doing Charset lookups, they all get</span><br><span class="line">        // blocked and must wait, severely dropping throughput.</span><br><span class="line">        //</span><br><span class="line">        ByteBuffer buf = utf8Charset.encode(CharBuffer.wrap(str));</span><br><span class="line">        byte b[] = new byte[buf.limit()];</span><br><span class="line">        buf.get(b, 0, buf.limit());</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里直接调用了java.nio.charset.Charset的encode()方法。</p>
<p>综上所知，<b>PostgreSQL driver并没有对单引号、分号和双横杠对转义处理，而是由PG server做的处理。</b></p>
<p>其实PreparedStatement就是交由服务器预先编译，再由应用程序动态设置参数，相对直接操作JDBC，可以提升server端运行效率。PG server应该是对预编译情况下的输入参数做了特殊处理，防止SQL注入等安全问题。</p>
<p>再看下面的问题，如果SQL语句查询时，where条件不是字符类型，而是int类型，能否避免SQL注入？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;select * from user_tbl where id = ?&quot;;</span><br></pre></td></tr></table></figure></p>
<p>id为integer类型，输入 1; drop table user_tbl; ，PreparedStatement执行直接报错了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.postgresql.util.PSQLException: ERROR: operator does not exist: integer = character varying</span><br><span class="line">  建议：No operator matches the given name and argument type(s). You might need to add explicit type casts.</span><br><span class="line">  位置：32</span><br></pre></td></tr></table></figure></p>
<p>用<a href="https://github.com/p6spy/p6spy" target="_blank" rel="noopener">p6spy</a>来打印SQL语句，发现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user_tbl where id = &apos;1; drop table user_tbl;&apos;</span><br></pre></td></tr></table></figure></p>
<p>id为integer类型，也被当成字符串来处理了，自动加了单引号。PostgreSQL driver应该是自动把integer, long等类型都当成string提交给server，由server根据表的schema定义会自动转化。这里id定义的是int型，server端转换类型出错了。</p>
<p>PostgreSQL server本身支持Prepare语法，用法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PREPARE p_st AS SELECT * FROM user_tbl WHERE name = ($1);</span><br><span class="line"></span><br><span class="line">EXECUTE p_st(&apos;&apos;&apos; or 1=1&apos;)</span><br></pre></td></tr></table></figure></p>
<p>查询结果为空，pg server自动处理了特殊参数。$1 称为<b>bind variables（绑定变量）</b>，MySQL也支持Prepare语法。</p>
<p>如果直接拼接字符串，再把SQL扔给pg server，它是不会做防SQL注入处理的。</p>
<p>在使用某个数据库时，要测试，确认PreparedStatement是否能防SQL注入。也可以在应用层，由程序自动过滤掉单引号、分号和双横杠，可能会损失一些特殊的合法值查询，但可以避免出现SQL注入问题。</p>
<p>[参考文献]<br>1、<a href="https://en.wikipedia.org/wiki/SQL_injection" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/SQL_injection</a><br>2、<a href="https://www.postgresql.org/docs/9.3/static/sql-prepare.html" target="_blank" rel="noopener">https://www.postgresql.org/docs/9.3/static/sql-prepare.html</a><br>3、<a href="https://dev.mysql.com/doc/refman/5.5/en/sql-syntax-prepared-statements.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/sql-syntax-prepared-statements.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      

    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/13/Mac上搭建Hadoop-Hive-Spark开发环境/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Rui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TechLiving">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/13/Mac上搭建Hadoop-Hive-Spark开发环境/" itemprop="url">Mac上搭建Hadoop+Hive+Spark开发环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-13T10:14:37+08:00">
                2018-04-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/13/Mac上搭建Hadoop-Hive-Spark开发环境/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/04/13/Mac上搭建Hadoop-Hive-Spark开发环境/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在学习java大数据组件，被hadoop+hive+spark等组件的各种抽象概念搞的云里雾里。文档和书都在读，但如果不去实际运行demo和example，终归记不住，缺乏深刻的印象。</p>
<p>对学习一门新技术新框架，我的经验是第一步看文档，建立初步的概念和印象，第二步跑demo，更直观的看常见的API有哪些，程序是如何调用的，第三步，就是项目中实战运用。最后一步，要精深，需要debug跟进源码。</p>
<p>前段时间基本完成了第一步，对这些大数据组件有了基本的概念，现在准备学习demo，实际运行。网上有很多教程来搭建本地学习环境，但真正动手做起来，才发现还是会遇到各种问题。大家搭建的版本不一样，操作系统环境不一样，遇到的问题也是不一样的。零零碎碎的查官方文档和其他教程，花了将近2天的时间，才真正在Mac系统上搭建起来。</p>
<p>我始终觉得mac做开发，相对windows还是很有优势的，毕竟mac更像linux，配置起来更方便。既然自己也花了这么长时间才搭建好开发环境，就有必要总结和记录一下了。</p>
<p>主要是为了学习spark的examples，由于spark最新版本是2.3.0，依赖的hive是1.2.1版本。而brew安装hadoop和hive的版本依次是3.0.0和2.3.0，运行spark sql时，会出问题。</p>
<p>第一次运行bin/spark-submit –class “org.apache.spark.examples.sql.hive.JavaSparkHiveExample” spark-examples-1.0-SNAPSHOT.jar，会成功在hive中创建src表，但第二次运行时会报错：”org.apache.spark.sql.catalyst.analysis.NoSuchDatabaseException: Database ‘default’ not found;”</p>
<p>用maven dependency:tree来看依赖情况，spark sql依赖的是hive 1.2.1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[INFO] \- org.apache.spark:spark-hive_2.11:jar:2.3.0:compile</span><br><span class="line">[INFO]    +- com.twitter:parquet-hadoop-bundle:jar:1.6.0:compile</span><br><span class="line">[INFO]    +- org.spark-project.hive:hive-exec:jar:1.2.1.spark2:compile</span><br><span class="line">[INFO]    |  +- commons-io:commons-io:jar:2.4:compile</span><br><span class="line">// ......</span><br><span class="line"></span><br><span class="line">[INFO]    +- org.spark-project.hive:hive-metastore:jar:1.2.1.spark2:compile</span><br><span class="line">[INFO]    |  +- com.jolbox:bonecp:jar:0.8.0.RELEASE:compile</span><br><span class="line">[INFO]    |  +- commons-cli:commons-cli:jar:1.2:compile</span><br><span class="line">[INFO]    |  +- commons-logging:commons-logging:jar:1.1.3:compile</span><br><span class="line">// ......</span><br></pre></td></tr></table></figure></p>
<p>所以手工从官网下载hive 1.2.1版本。从官网更新时间来说，hive 1.2.1 和 2.3.3 是目前主力版本。hive 2相当第一代产品有哪些新功能，后面再研究。</p>
<h3 id="Hadoop-2-6-5-搭建"><a href="#Hadoop-2-6-5-搭建" class="headerlink" title="Hadoop 2.6.5 搭建"></a>Hadoop 2.6.5 搭建</h3><p>1、编辑配置文件<br>etc/hadoop/core-site.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/Users/liaorui/data/hadoop2/hdfs-tmp&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意要配置hadoop.tmp.dir，因为默认hadoop是把数据存在/tmp下的，电脑重启后会丢失。</p>
<p>etc/hadoop/hdfs-site.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>etc/hadoop/mapred-site.xml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.application.classpath&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>2、格式化dfs文件系统，并启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ bin/hdfs namenode -format</span><br><span class="line"></span><br><span class="line"># Start NameNode daemon and DataNode daemon:</span><br><span class="line">$ sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></p>
<p>3、建立执行MapReduce任务的HDFS目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bin/hdfs dfs -mkdir /user</span><br><span class="line">$ bin/hdfs dfs -mkdir /user/&lt;username&gt;</span><br></pre></td></tr></table></figure></p>
<p>4、启动yarn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#Start ResourceManager daemon and NodeManager daemon:</span><br><span class="line">$ sbin/start-yarn.sh</span><br><span class="line"></span><br><span class="line">#Browse the web interface for the ResourceManager; by default it is available at:</span><br><span class="line">    * ResourceManager - http://localhost:8088/</span><br><span class="line"></span><br><span class="line">#When you’re done, stop the daemons with:</span><br><span class="line">$ sbin/stop-yarn.sh</span><br></pre></td></tr></table></figure></p>
<h3 id="Hive-1-2-1搭建"><a href="#Hive-1-2-1搭建" class="headerlink" title="Hive 1.2.1搭建"></a>Hive 1.2.1搭建</h3><p>1、hive配置<br>conf/hive-site.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;jdbc:mysql://localhost/metastore&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;the URL of the MySQL database&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hive&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hive&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;datanucleus.autoCreateSchema&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;datanucleus.fixedDatastore&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;datanucleus.autoStartMechanism&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;SchemaTable&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hive.metastore.uris&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;thrift://localhost:9083&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;IP address (or fully-qualified domain name) and port of the metastore host&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>2、创建mysql database<br>hive的数据存储在hdfs上，但库表元信息metastore是存储在第三方数据库的。默认是用derby内嵌启动的，但无法多用户访问。所以通常是用mysql或postgresql作为metastore存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">Enter password:</span><br><span class="line">mysql&gt; CREATE DATABASE metastore;</span><br><span class="line">mysql&gt; USE metastore;</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE USER &apos;hive&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;hive&apos;;</span><br><span class="line">...</span><br><span class="line">mysql&gt; REVOKE ALL PRIVILEGES, GRANT OPTION FROM &apos;hive&apos;@&apos;localhost&apos;;</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON metastore.* TO &apos;hive&apos;@&apos;localhost&apos;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">mysql&gt; quit;</span><br></pre></td></tr></table></figure>
<p>3、将mysql connector驱动复制到hive/lib目录下，注意用 mysql-connector-java-5.1.22.jar 及以后版本。更早版本可能会报错：<br>com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘OPTION SQL_SELECT_LIMIT=DEFAULT’ at line 1</p>
<p>4、设置HADOOP_HOME环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Hive uses Hadoop, so you must have Hadoop in your path OR</span><br><span class="line"></span><br><span class="line">$ export HADOOP_HOME=&lt;hadoop-install-dir&gt;</span><br></pre></td></tr></table></figure></p>
<p>5、在dfs中建立hive需要的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ $HADOOP_HOME/bin/hadoop fs -mkdir /tmp</span><br><span class="line">$ $HADOOP_HOME/bin/hadoop fs -mkdir /user/hive/warehouse</span><br><span class="line">$ $HADOOP_HOME/bin/hadoop fs -chmod g+w /tmp</span><br><span class="line">$ $HADOOP_HOME/bin/hadoop fs -chmod g+w /user/hive/warehouse</span><br></pre></td></tr></table></figure></p>
<p>6、初始化metastore数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HIVE_HOME/bin/schematool -dbType mysql -initSchema</span><br></pre></td></tr></table></figure></p>
<p>HiveServer2 (HS2) is a server interface that enables remote clients to execute queries against Hive and retrieve the results (a more detailed intro here). The current implementation, based on Thrift RPC, is an improved version of HiveServer and supports multi-client concurrency and authentication. It is designed to provide better support for open API clients like JDBC and ODBC. </p>
<p>7、运行metastore服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hive --service metastore</span><br></pre></td></tr></table></figure></p>
<h3 id="Spark-2-3-3搭建"><a href="#Spark-2-3-3搭建" class="headerlink" title="Spark 2.3.3搭建"></a>Spark 2.3.3搭建</h3><p>1、将hadoop的core-site.xml、hdfs-site.xml和hive的hive-site.xml 放在spark的conf下，spark会自动加载hive。</p>
<p>2、将hive-exec-1.2.1.spark2.jar、hive-metastore-1.2.1.spark2.jar、libfb303-0.9.3.jar、libthrift-0.9.3.jar、spark-hive_2.11-2.3.0.jar 放到spark的jars目录。<br>将hive/lib/jline-2.12.jar放到hadoop/share/hadoop/yarn/lib目录，并删除旧版本hive/lib/jline-0.9.jar。</p>
<p>3、将spark/examples目录的demo源码新建maven工程，pom.xml如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spark-mllib_2.11&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spark-streaming-kafka-0-10_2.11&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.github.scopt&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;scopt_2.11&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spark-hive_2.11&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p>
<p>将spark examples导入转成maven工程，就方便在idea或eclipse里debug学习了，也方便编译成jar，用spark-submit提交任务。</p>
<p>4、提交spark任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit --class &quot;org.apache.spark.examples.sql.hive.JavaSparkHiveExample&quot; spark-examples-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></p>
<p>至此，可以运行spark的examples程序了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      

    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/29/Docker构建Python应用镜像/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Rui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TechLiving">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/Docker构建Python应用镜像/" itemprop="url">Docker构建Python应用镜像</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T14:35:51+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/29/Docker构建Python应用镜像/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/03/29/Docker构建Python应用镜像/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近需要将Python应用程序部署上线，而用户现场的服务器基于安全原因，是不能访问外网的。Python需要访问Postgresql、Hive和ElasticSearch，需要psycopg2-binary、pyhs2、elasticsearch等插件。在测试环境下，通过pip install就能解决，但纯内网环境下，pip失去了作用。</p>
<p>pyhs2还依赖于cyrus-sasl-devel，有网情况下是通过yum install安装并自动解决rpm包的依赖问题的。另外，nginx、openssl都需要在线内网环境下安装，并且客户机上没有gcc和gcc-c++。</p>
<p>我们一开始是手工下载各类rpm包，然后rpm -ivh手工安装，很快就陷入了万恶的rpm无限依赖。等最后装上这些环境时，相关rpm依赖包达到了50个以上，非常痛苦。</p>
<p>尝试用docker解决这些依赖包问题，期望将Python程序运行需要的rpm和pip插件全部打包成一个镜像，然后在客户机上，直接导入镜像，方便运行。网上关于docker的教程已经很好了，但还是再做一下记录，以备将来之需。</p>
<p>先在测试环境搭一套docker，然后在公共仓库下载一个linux环境。可以根据用户现场的服务器版本，下载对应的linux镜像。我们将在这个镜像的基础上，加入各种依赖文件。这个测试环境，必须是有网的。Docker现在支持Linux, Mac OS, Windows，基于覆盖了常用的各种桌面PC。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos:7.2.1511</span><br></pre></td></tr></table></figure></p>
<p>下载完成后，通过 docker images 查看镜像已经在我们本地了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY      TAG             IMAGE ID            CREATED             SIZE</span><br><span class="line">centos          7.2.1511        0a2bad7da9b5        4 months ago        195MB</span><br></pre></td></tr></table></figure></p>
<p>启动CentOS，只需要进入bash环境即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8001:8001 -ti &lt;IMAGE ID&gt; /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>IMAGE ID通过docker images查看，只需要输入前4位即可，docker会自动识别。比如上面的IMAGE ID是0a2b。<br>-p参数是将docker的8001端口映射到宿主机的8001端口上，这样就可以在本地机器上通过8001端口直接访问Python程序的接口服务。<br>更多参数通过 docker run –help 来查看。</p>
<p>接下来，    就可以像在物理机一样操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum -y install python-devel</span><br><span class="line">yum -y install cyrus-sasl-devel</span><br><span class="line"></span><br><span class="line">curl https://bootstrap.pypa.io/get-pip.py | python</span><br><span class="line">pip install flask</span><br><span class="line">pip install pyhs2</span><br><span class="line">pip install psycopg2-binary</span><br><span class="line">pip install elasticsearch</span><br><span class="line">pip install pyyaml</span><br><span class="line">pip install requests</span><br></pre></td></tr></table></figure></p>
<p>装好Python环境后，需要将Python程序复制到镜像里面，新开一个终端，运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp python_app &lt;CONTAINER ID&gt;:/root</span><br></pre></td></tr></table></figure></p>
<p>CONTAINER ID在 docker ps 中看。只需要输入前4位即可，docker会自动识别。</p>
<p>最后，启动Python程序即可。</p>
<p>如果上述步骤都成功了，就可以将当前正在运行的docker容器保存为镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;CONTAINER ID&gt; py_docker</span><br></pre></td></tr></table></figure></p>
<p>再通过 docker images 查看是否存在py_docker。</p>
<p>这个py_docker就是一个完整的Python运行环境，包含了所有的相关依赖。</p>
<p>通过以下命令将镜像导出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save py_docker &gt; py_docker</span><br></pre></td></tr></table></figure></p>
<p>现在我们拿到这个镜像文件了，带到客户现场去，直接导入客户机上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; py_docker</span><br></pre></td></tr></table></figure></p>
<p>用以下命令来启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8001:8001 -ti py_docker</span><br></pre></td></tr></table></figure></p>
<p>通过这些简单的步骤，就解决了在内网环境下，安装Python或其他应用环境所面临的复杂的依赖包。</p>
<p>如果服务器上连docker也没有，就需要先安装docker。其实docker本身通过rpm安装，也是一堆的依赖。下一篇文章将介绍yum离线仓库的构建方法，将docker依赖的rpm全部离线下载，然后拷到客户机上，本地安装。当docker装上后，后面的各种开发环境和应用环境就好解决了，微服务和应用隔离，就可以快乐的实施了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      

    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/EnableEurekaServer注解如何启动Eureka-Server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Rui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TechLiving">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/EnableEurekaServer注解如何启动Eureka-Server/" itemprop="url">EnableEurekaServer注解如何启动Eureka Server</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T17:47:26+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/23/EnableEurekaServer注解如何启动Eureka-Server/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/03/23/EnableEurekaServer注解如何启动Eureka-Server/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Spring Cloud目前是Java世界里微服务的标准解决方案，它基于Spring Boot，用注解的方式很优雅地将Spring Boot项目加上各种微服务功能，如服务发现，负载均衡，服务熔断等。Spring Cloud包括了Eureka, hystrix, zuul, feign, sleuth, ribbon, turbine等组件。</p>
<p>@EnableEurekaServer魔法一样的将一个普通的Spring Boot应用变成了Eureka的注册中心，如此简单快捷，它是怎么做到的呢？</p>
<p>先看Spring Boot的入口程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableEurekaServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pom.xml引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>spring-cloud-starter-eureka-server依赖于spring-cloud-netflix-eureka-server，而spring-cloud-netflix-eureka-server又依赖于spring-boot-starter-web。spring-boot-starter-web又会引入tomcat embedded。</p>
<p>web(true)方法会将SpringApplication的webEnvironment置为true，上一篇文章<a href="/2018/03/21/Spring%20Boot如何加载tomcat/">《Spring Boot如何加载tomcat》</a>分析了SpringApplication在检测到web环境后，会自动启动tomcat。</p>
<p>@EnableEurekaServer的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(EurekaServerConfiguration.class)</span><br><span class="line">public @interface EnableEurekaServer &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用Import注解导入了EurekaServerConfiguration，继续跟踪下去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Import(EurekaServerInitializerConfiguration.class)</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableConfigurationProperties(EurekaDashboardProperties.class)</span><br><span class="line">@PropertySource(&quot;classpath:/eureka/server.properties&quot;)</span><br><span class="line">public class EurekaServerConfiguration extends WebMvcConfigurerAdapter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>EurekaServerInitializerConfiguration的实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class EurekaServerInitializerConfiguration</span><br><span class="line">		implements ServletContextAware, SmartLifecycle, Ordered &#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private EurekaServerBootstrap eurekaServerBootstrap;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					//TODO: is this class even needed now?</span><br><span class="line">					eurekaServerBootstrap.contextInitialized(EurekaServerInitializerConfiguration.this.servletContext);</span><br><span class="line">					log.info(&quot;Started Eureka Server&quot;);</span><br><span class="line"></span><br><span class="line">					publish(new EurekaRegistryAvailableEvent(getEurekaServerConfig()));</span><br><span class="line">					EurekaServerInitializerConfiguration.this.running = true;</span><br><span class="line">					publish(new EurekaServerStartedEvent(getEurekaServerConfig()));</span><br><span class="line">				&#125;</span><br><span class="line">				catch (Exception ex) &#123;</span><br><span class="line">					// Help!</span><br><span class="line">					log.error(&quot;Could not initialize Eureka servlet context&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>EurekaServerInitializerConfiguration实现了SmartLifecycle接口，start()方法会自动被Spring框架调用。eurekaServerBootstrap是通过@Autowired自动导入的，因为EurekaServerConfiguration类里有如下@Bean注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public EurekaServerBootstrap eurekaServerBootstrap(PeerAwareInstanceRegistry registry,</span><br><span class="line">		EurekaServerContext serverContext) &#123;</span><br><span class="line">	return new EurekaServerBootstrap(this.applicationInfoManager,</span><br><span class="line">			this.eurekaClientConfig, this.eurekaServerConfig, registry,</span><br><span class="line">			serverContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>得到EurekaServerBootstrap的实例后，就依照EurekaBootstrap的实现，将eureka启动起来。</p>
<p>我们看netflix的eureka的<a href="https://github.com/Netflix/eureka/blob/master/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java" target="_blank" rel="noopener">EurekaBootstrap</a>代码，它实现了ServletContextListener接口，并且在<a href="https://github.com/Netflix/eureka/blob/master/eureka-server/src/main/webapp/WEB-INF/web.xml" target="_blank" rel="noopener">web.xml</a>中声明了<listener></listener>。因此eureka是作为一个标准的web应用，打包成war包放在tomcat容器里运行的。</p>
<p>而spring-cloud-starter-eureka-server巧妙地将标准的web应用结构转换成Spring Boot项目，并用EurekaServerBootstrap模拟了EurekaBootStrap的行为，二者的代码实现基本是一致的，都对eureka服务进行了配置。但EurekaServerBootstrap并没有实现ServletContextListener接口，更没有在web.xml中声明listener。Spring Boot项目压根就没有web.xml。</p>
<p>以上简要地分析了一个@EnableEurekaServer注解是如何实现eureka服务注册中心的，我们还可以深入学习EurekaServerBootstrap和EurekaBootStrap代码，看看eureka是怎么配置的。官方文档上说eureka的server和client的通讯协议是JSON格式的，通过Jersy和XStream传递，后面继续研究具体的通讯过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      

    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/21/Spring Boot如何加载tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Rui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TechLiving">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Spring Boot如何加载tomcat/" itemprop="url">Spring Boot如何加载tomcat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-21T10:05:44+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/21/Spring Boot如何加载tomcat/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/03/21/Spring Boot如何加载tomcat/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有同事说面试时被问到Spring Boot是如何加载tomcat的，我也是一脸懵逼。特意debug了一下，大致的加载过程如下图所示:</p>
<p><img src="/2018/03/21/Spring Boot如何加载tomcat/spring boot load tomcat.png" alt=""></p>
<p>Spring Boot web项目，只需要在pom.xml中引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>在github上看spring-boot-starter-web的pom.xml定义，有如下依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>默认加载了tomcat作为web容器。</p>
<p>我们的应用项目启动入口是：SpringApplication.run(Application.class, args)，其中Application.class是包含main()的主类。跟踪到run()方法里面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">		......</span><br><span class="line">		context = createApplicationContext(); //</span><br><span class="line">		......</span><br><span class="line">		refreshContext(context);</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里并没有看到启动tomcat的相关代码。程序的层次结构有些深，大量运用了Java多态特性，基于接口编程，我们看到的都是对接口方法的调用，很难知道具体是哪一个子类实现。</p>
<p>换个思路，从程序运行的log日志里找线索，运行程序，在控制台上找到如下日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">2018-03-21 10:55:36.413  INFO 8424 --- [           main] ConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@77e9807f: startup date [Wed Mar 21 10:55:36 CST 2018]; root of context hierarchy</span><br><span class="line">2018-03-21 10:55:38.847  INFO 8424 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>第一次出现tomcat信息的log是在TomcatWebServer类里的initialize()方法，于是逆向溯源，向上查找，找到了TomcatServletWebServerFactory.getTomcatWebServer(Tomcat tomcat)调用，又找到TomcatServletWebServerFactory.getWebServer(ServletContextInitializer… initializers)。</p>
<p>继续向上查找，到了ServletWebServerApplicationContext.createWebServer()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void createWebServer() &#123;</span><br><span class="line">		WebServer webServer = this.webServer;</span><br><span class="line">		ServletContext servletContext = getServletContext();</span><br><span class="line">		if (webServer == null &amp;&amp; servletContext == null) &#123;</span><br><span class="line">			ServletWebServerFactory factory = getWebServerFactory(); // factory得到的具体实现是TomcatServletWebServerFactory</span><br><span class="line">			this.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">		&#125;</span><br><span class="line">		else if (servletContext != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				getSelfInitializer().onStartup(servletContext);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (ServletException ex) &#123;</span><br><span class="line">				throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;,</span><br><span class="line">						ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		initPropertySources();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>进一步看getWebServerFactory()的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected ServletWebServerFactory getWebServerFactory() &#123;</span><br><span class="line">		// Use bean names so that we don&apos;t consider the hierarchy</span><br><span class="line">		String[] beanNames = getBeanFactory()</span><br><span class="line">				.getBeanNamesForType(ServletWebServerFactory.class);  // beanNames数组只有一个元素，且为tomcatServletWebServerFactory</span><br><span class="line">		if (beanNames.length == 0) &#123;</span><br><span class="line">			throw new ApplicationContextException(</span><br><span class="line">					&quot;Unable to start ServletWebServerApplicationContext due to missing &quot;</span><br><span class="line">							+ &quot;ServletWebServerFactory bean.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (beanNames.length &gt; 1) &#123;</span><br><span class="line">			throw new ApplicationContextException(</span><br><span class="line">					&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot;</span><br><span class="line">							+ &quot;ServletWebServerFactory beans : &quot;</span><br><span class="line">							+ StringUtils.arrayToCommaDelimitedString(beanNames));</span><br><span class="line">		&#125;</span><br><span class="line">		return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class)用来从classpath中查找具体哪个容器类（tomcat, jetty，netty或undertow），具体怎么实现的呢？</p>
<p>Spring Boot启动类加上@SpringBootApplication或@EnableAutoConfiguration注解后，会导入一个AutoConfigurationImportSelector的类，而这个类会去读取spring-boot-autoconfigure包里spring.factories下key为EnableAutoConfiguration对应的全限定名的值，其中包含了ServletWebServerFactoryAutoConfiguration这个类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line">@ConditionalOnClass(ServletRequest.class)</span><br><span class="line">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="line">@EnableConfigurationProperties(ServerProperties.class)</span><br><span class="line">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span><br><span class="line">		ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span><br><span class="line">		ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span><br><span class="line">		ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span><br><span class="line">public class ServletWebServerFactoryAutoConfiguration &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>又通过@Import注解引用了ServletWebServerFactoryConfiguration类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class ServletWebServerFactoryConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	@Configuration</span><br><span class="line">	@ConditionalOnClass(&#123; Servlet.class, Tomcat.class, UpgradeProtocol.class &#125;)</span><br><span class="line">	@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line">	public static class EmbeddedTomcat &#123;</span><br><span class="line">		@Bean</span><br><span class="line">		public TomcatServletWebServerFactory tomcatServletWebServerFactory() &#123;</span><br><span class="line">			return new TomcatServletWebServerFactory();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Nested configuration if Jetty is being used.</span><br><span class="line">	 */</span><br><span class="line">	@Configuration</span><br><span class="line">	@ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class,</span><br><span class="line">			WebAppContext.class &#125;)</span><br><span class="line">	@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line">	public static class EmbeddedJetty &#123;</span><br><span class="line">		@Bean</span><br><span class="line">		public JettyServletWebServerFactory JettyServletWebServerFactory() &#123;</span><br><span class="line">			return new JettyServletWebServerFactory();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Nested configuration if Undertow is being used.</span><br><span class="line">	 */</span><br><span class="line">	@Configuration</span><br><span class="line">	@ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;)</span><br><span class="line">	@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line">	public static class EmbeddedUndertow &#123;</span><br><span class="line">		@Bean</span><br><span class="line">		public UndertowServletWebServerFactory undertowServletWebServerFactory() &#123;</span><br><span class="line">			return new UndertowServletWebServerFactory();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过@ConditionalOnClass和@ConditionalOnMissingBean注解，在classpath中寻找tomcat或jetty或undertow的jar包。</p>
<p>spring-boot-starter-web默认加载了spring-boot-starter-tomcat，进而加载了tomcat-embed-core，所以这里得到了tomcatServletWebServerFactory，并通过getTomcatWebServer(Tomcat tomcat)实例化TomcatWebServer，最终TomcatWebServer调用initialize()方法完成tomcat.start()调用。</p>
<p>读取spring.factories文件的实现是通过org.springframework.core.io.support.SpringFactoriesLoader实现。SpringFactoriesLoader的实现类似于SPI（Service Provider Interface，在java.util.ServiceLoader的文档里有比较详细的介绍。java SPI提供一种服务发现机制，为某个接口寻找服务实现的机制。SpringFactoriesLoader会加载classpath下所有JAR文件里面的META-INF/spring.factories文件。</p>
<p>JettyServletWebServerFactory和UndertowServletWebServerFactory，也继承了AbstractServletWebServerFactory，为何它们没有被getBeanNamesForType(ServletWebServerFactory.class)获取到呢? 查看他们的源码，可以看到分别import了org.eclipse.jetty.*和io.undertow.*，但我们并没有在项目中引入jetty或undertow，所以JettyServletWebServerFactory和UndertowServletWebServerFactory是没办法通过getBeanFactory().getBean(name, ServletWebServerFactory.class)来实例化的。</p>
<p><img src="/2018/03/21/Spring Boot如何加载tomcat/servletwebserverfactory.png" alt=""></p>
<p>如果pom.xml中同时加了tomcat和jetty，beanNames会得到两个元素，元素个数超过1，也会报错：“Unable to start ServletWebServerApplicationContext due to multiple ServletWebServerFactory beans”。</p>
<p>另外一个问题是，Spring Boot是怎么判断是否是一个web应用，并自动加载对应的web容器的？这是由SpringApplication的webEnvironment变量来标识的。</p>
<p>当工程的pom.xml文件里引入了spring-boot-starter-web，SpringApplication.run()方法会调用new SpringApplication(sources).run(args)，然后在void initialize(Object[] sources)方法里对webEnvironment赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">this.webEnvironment = deduceWebEnvironment();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">private boolean deduceWebEnvironment() &#123;</span><br><span class="line">	for (String className : WEB_ENVIRONMENT_CLASSES) &#123;</span><br><span class="line">		if (!ClassUtils.isPresent(className, null)) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">private static final String[] WEB_ENVIRONMENT_CLASSES = &#123; &quot;javax.servlet.Servlet&quot;,</span><br><span class="line">&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot; &#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">private ConfigurableEnvironment getOrCreateEnvironment() &#123;</span><br><span class="line">		if (this.environment != null) &#123;</span><br><span class="line">			return this.environment;</span><br><span class="line">		&#125;</span><br><span class="line">		if (this.webEnvironment) &#123;</span><br><span class="line">			return new StandardServletEnvironment();</span><br><span class="line">		&#125;</span><br><span class="line">		return new StandardEnvironment();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>从以上代码里可以看到，通过反射技术判断Java环境变量里是否有Servlet和ConfigurableWebApplicationContext,如果都找到了，webEnvironment置为ture，并在后面创建StandardServletEnvironment的配置环境，最后启动web容器。</p>
<p>注意以上是基于spring boot 2.0版本的分析，而1.5的版本，是用EmbeddedWebApplicationContext和TomcatEmbeddedServletContainerFactory来实现的。</p>
<p>spring-boot-starter总共提供了51个常用的库加载，很方便的简化了第三方库的引用和配置，都值得我们应用和学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      

    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/14/飞机经纬度连线消除锯齿/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Rui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TechLiving">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/14/飞机经纬度连线消除锯齿/" itemprop="url">飞机经纬度连线消除锯齿</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-14T20:30:45+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/14/飞机经纬度连线消除锯齿/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/03/14/飞机经纬度连线消除锯齿/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在<a href="https://liaorui.github.io/2018/02/02/ADS-B%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">ADS-B简介</a>这篇文章里，介绍了ADS-B的数据样式。利用ADS-B的数据，我们可以做出类似<a href="https://www.flightradar24.com" target="_blank" rel="noopener">Flightradar24</a>这样酷炫的飞机轨迹图，只要把一系统连续点的经、纬度在地图上连线即可。</p>
<p>像Flightradar24这样的专业ADS-B数据商，都会有多种ADS-B数据源。拿到几个接收器或几个数据源的数据后，需要进行整合。如果仅仅按获取到的实时位置的创建时间来整合，则在地图上画出来的曲线会存在锯齿。原因是各个ADS-B接收器的规格、参数、网络的差异，对同一区域的同一架飞机的监控，各个设备获取到的经纬度数据也可能存在误差。</p>
<p>这里利用Thaddeus Vincenty的地理空间经纬度算法，消除明显的棱角，得到比较顺滑的曲线。Java代码实现在这里：<a><a href="https://github.com/mgavaghan/geodesy" target="_blank" rel="noopener">https://github.com/mgavaghan/geodesy</a></a></p>
<p>思路是，根据上一个位置的<b>经纬度、速度、航向、飞行时间</b>（上一个时间距离当前的时间的时长），推算出下一个飞行到达的位置（理论位置），并跟当前位置（从ADS-B数据源拿到的位置）进行比较。如果在一个合理的误差范围，则认为数据源提供的当前位置有效，否则认为数据源给的当前位置无效，会出现锯齿，应丢弃。</p>
<p>关键代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (lastRB24Log != null) &#123;</span><br><span class="line">    int seconds = DateTimeUtil.getDateDiffSecond(planeLog.getCreateTime(), lastRB24Log.getCreateTime());</span><br><span class="line">    double flyLen = GpsGeometryCalculate.getMetricLenght(lastRB24Log.getSpeed(), seconds);</span><br><span class="line">    double[] calPoint = GpsGeometryCalculate.calEndPointGps(lastRB24Log.getLatitude(), lastRB24Log.getLongitude(), flyLen, lastRB24Log.getCourse());</span><br><span class="line">    double latDelta = Math.abs(calPoint[0] - planeLog.getLatitude());</span><br><span class="line">    double lonDelta = Math.abs(calPoint[1] - planeLog.getLongitude());</span><br><span class="line">    if (seconds &lt; 120 &amp;&amp; (latDelta &gt; 0.1 &amp;&amp; latDelta &lt; 1) || (lonDelta &gt; 0.1 &amp;&amp; lonDelta &lt; 1)) &#123;</span><br><span class="line">        // 2分钟内，纬度或经度跨度太大，不合理，需要丢弃</span><br><span class="line">        continue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        lastRB24Log = planeLog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中getMetricLenght()和calEndPointGps()方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 速度转换常数 1kn(节） =1.852km/小时</span><br><span class="line">private static double KN_TO_KM = 1.852;</span><br><span class="line"></span><br><span class="line">public static double getMetricLenght(int kn, int runTime) &#123;</span><br><span class="line">    return kn * KN_TO_KM * runTime / 3600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static double[] calEndPointGps(Double lastLat, Double lastLng, double flyingLenght, double azimuth) &#123;</span><br><span class="line">    GeodeticCalculator geoCalc = new GeodeticCalculator();</span><br><span class="line"></span><br><span class="line">    // select a reference elllipsoid</span><br><span class="line">    Ellipsoid reference = Ellipsoid.WGS84;</span><br><span class="line"></span><br><span class="line">    // set Lincoln Memorial coordinates</span><br><span class="line">    GlobalCoordinates lincolnMemorial;</span><br><span class="line">    lincolnMemorial = new GlobalCoordinates(lastLat, lastLng);</span><br><span class="line"></span><br><span class="line">    // set the direction and distance</span><br><span class="line">    double startBearing = azimuth;</span><br><span class="line">    double distance = flyingLenght * 1000;</span><br><span class="line"></span><br><span class="line">    // find the destination</span><br><span class="line">    double[] endBearing = new double[1];</span><br><span class="line">    GlobalCoordinates dest = geoCalc.calculateEndingGlobalCoordinates(reference, lincolnMemorial, startBearing,</span><br><span class="line">            distance, endBearing);</span><br><span class="line">    return new double[] &#123; dest.getLatitude(), dest.getLongitude() &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的120秒，纬度或经度跨度大于0.1，是经验值，需要根据大量测试数据对比得到。</p>
<p>如果飞机在空中转弯或画圈，飞行轨迹为弧线，如果ADS-B信号不好，拿到的位置点不连续，也会导致地图上画的线成了折线，不够圆滑。于是想到用<a href="http://www.cnblogs.com/hnfxs/p/3148483.html" target="_blank" rel="noopener">贝塞尔曲线</a>算法，来拟合曲线上的点，让画出来的曲线看起来更圆滑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">double geolat1 = 36.5467;</span><br><span class="line">double geolon1 = 101.7883;</span><br><span class="line">    </span><br><span class="line">double geolat2 = 36.5044;</span><br><span class="line">double geolon2 = 101.8472;</span><br><span class="line"></span><br><span class="line">// 控制点</span><br><span class="line">double contrlat = 36.5250;</span><br><span class="line">double contrlon = 101.8175;</span><br><span class="line"></span><br><span class="line">// 贝塞尔曲线</span><br><span class="line">for (float t = 0.1f; t &lt; 1; t += 0.2) &#123;</span><br><span class="line">    double x = (1 - t) * (1 - t) * geolat1 + 2 * (1 - t) * t * contrlat + t * t * geolat2;</span><br><span class="line">    double y = (1 - t) * (1 - t) * geolon1 + 2 * (1 - t) * t * geolon2 + t * t * contrlon;</span><br><span class="line">    System.out.println(x + &quot;, &quot; + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假定只拿到弧线上的两个点(36.5467,101.7883),(36.5044,101.8472)，选择一个控制点(36.5250,101.8175)，控制变量t从0到1的变换中，拟合出很多点，这些点组成的曲线看起来有很好的弧形。</p>
<p>而实际上，控制点很难选择和确定，后续项目中再慢慢研究吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      

    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/最长上升子序列LIS判断飞机高度的变化趋势/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Rui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TechLiving">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/最长上升子序列LIS判断飞机高度的变化趋势/" itemprop="url">最长上升子序列LIS判断飞机高度的变化趋势</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T13:33:31+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/09/最长上升子序列LIS判断飞机高度的变化趋势/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/03/09/最长上升子序列LIS判断飞机高度的变化趋势/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LIS（Longest Increasing Subsequence）定义: 给出一个序列a1,a2,a3,a4,a5,a6,a7….an,求它的一个子序列（设为s1,s2,…sn），使得这个子序列满足这样的性质，s1 &lt; s2 &lt; s3 &lt; … &lt; sn并且这个子序列的长度最长，输出这个最长的长度。<br>例如有一个序列:1  7  3  5  9  4  8，它的最长上升子序列就是1 3 4 8，长度为4。</p>
<p>有两种时间复杂度分别为O(N^2)和O(NlogN)的算法，关于这两种算法的描述，网上都有很多资料，这里不再赘述。对于O(NlogN)的算法，利用贪心的思想，对于一个上升子序列，显然当最后一个元素越小，越有利于添加新的元素，这样LIS长度自然更长。 </p>
<p>直接给出代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static int[] longestIncreasingSubsequence(int[] arr) &#123;</span><br><span class="line">        int i, n = arr.length, top, temp;</span><br><span class="line">        int[] stack = new int[n + 1];</span><br><span class="line">        int[] idxes = new int[n];</span><br><span class="line">        top = 0;</span><br><span class="line">        int idx = 0;// 记录LIS序列中元素对应的arr下标，便于修正LIS中下标错位的元素</span><br><span class="line">        </span><br><span class="line">        /* 为了方便top始终指向栈顶，stack从下标1开始使用，stack[0]设置为-1不使用 */</span><br><span class="line">        stack[0] = -1;</span><br><span class="line">        </span><br><span class="line">        // -----------------------------------------------------</span><br><span class="line">        // 一个for循环加一个二分查找，算法时间复杂度是o(NlogN)</span><br><span class="line">        // -----------------------------------------------------</span><br><span class="line">        for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            /* 比栈顶元素大数就入栈 */</span><br><span class="line">            if (temp &gt; stack[top]) &#123;</span><br><span class="line">                stack[++top] = temp;</span><br><span class="line">                idxes[idx++] = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int low = 1, high = top;</span><br><span class="line">                int mid;</span><br><span class="line">                /* 二分检索栈中比temp大的第一个数 */</span><br><span class="line">                while (low &lt;= high) &#123;</span><br><span class="line">                    mid = (low + high) / 2;</span><br><span class="line">                    if (temp &gt; stack[mid]) &#123;</span><br><span class="line">                        low = mid + 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        high = mid - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                /* 用temp替换 */</span><br><span class="line">                stack[low] = temp;</span><br><span class="line">                idxes[low - 1] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // -----------------------------------------------------</span><br><span class="line">        print(idxes);</span><br><span class="line">        int[] lis = Arrays.copyOfRange(stack, 1, top + 1);</span><br><span class="line">        print(lis); // 得到递增的最长子序列，但不一定是原数组的最长上升子序列</span><br><span class="line"></span><br><span class="line">        return lis;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>给定输入数组：2000 3325 2050 1990 1980 3335 7800 4025 4575 5625 6900 6800<br>得到的LIS为：1980 2050 3335 4025 4575 5625 6800<br>LIS在原数组的位置idxes为：4 2 5 7 8 9 11</p>
<p>可以看到LIS的第1个元素是1980，这个并不是源数据的最长上升子序列，因为顺序不对。但LIS的长度为7，却是正确的最长子序列的最大长度。</p>
<p>网上的各个博客到这里就结束了，只是算出来LIS的最大长度，并没有真正给出LIS。</p>
<p>针对上面出现的可能出现顺序错误的情况，需要进行修正。修正算法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// -----------------------------------------------------</span><br><span class="line">// 这里开始修正lis中顺序错乱的元素</span><br><span class="line">// -----------------------------------------------------</span><br><span class="line">for (int k = lis.length - 1; k &gt;= 1; k--) &#123;</span><br><span class="line">    if (idxes[k] &lt; idxes[k - 1]) &#123; // 下标错乱，需要修正</span><br><span class="line">        int max = 0;</span><br><span class="line">        int newIndex = 0;</span><br><span class="line">        for (int m = 0; m &lt; idxes[k]; m++) &#123; // 从lis[0..k-1]找出小于lis[k]的最大数</span><br><span class="line">            if (max &lt; arr[m] &amp;&amp; arr[m] &lt; lis[k]) &#123;</span><br><span class="line">                max = arr[m];</span><br><span class="line">                newIndex = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        idxes[k - 1] = newIndex;</span><br><span class="line">        lis[k - 1] = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过修正后的lis为：2000 2050 3335 4025 4575 5625 6800。第1个元素1980被替换成2000，这个就是正确的LIS了。</p>
<p>LIS算法在判断飞机高度变化趋势时很有用。地面的ADS-B接收器不断接收飞机的ADS-B广播，拿到一系列的经纬度和高度。怎么知道飞机刚从出发地起飞，还是准备降落目的地呢？</p>
<p>正常情况下，飞机刚起飞，高度不断增加，我们拿到高度序列后，直接判断最后一个高度大于第一个高度，就可以认为是起飞状态。但现在生活中，飞机因为大气气流的影响，起飞后为躲避气流，会来间断的下降后又上升，所以高度序列并不是连续递增的，例如：2000, 3125, 3325, 2000, 3325, 4025, 4575, 5625, 6900, 7925, 7950, 7925, 7700, 7275, 7050, 6925, 6500, 6350, 5400, 4825, 3150, 2250。</p>
<p>利用LIS算法，可以知道最大上升子序列为：2000 3125 3325 4025 4575 5625 6900 7925 7950，<br>高度序列逆序后再用LIS算法计算，得到最大下降子序列为：7950 7925 7700 7275 7050 6925 6500 6350 5400 4825 3150 2250。因此可以判定飞机是处于下降的趋势，而直接根据首尾判断却是上升趋势。</p>
<p>实际应用中，为了减少误判，高度序列要尽可能长些，多一些数据才能更准确反映出变化趋势。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      

    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpeg"
                alt="Liao Rui" />
            
              <p class="site-author-name" itemprop="name">Liao Rui</p>
              <p class="site-description motion-element" itemprop="description">Java</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liao Rui</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'gBKAh0rYcnxSinc8tu0HIpLg-gzGzoHsz',
        appKey: 'mIuTlwW0NmX5kNaFXMqCCEPi',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
