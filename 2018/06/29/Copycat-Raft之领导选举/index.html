<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Raft," />










<meta name="description" content="Raft是一种基于日志复制的分布式一致性算法，它提供了和Paxos算法相同的功能和性能，但更容易理解并且更容易构建实际的系统。Raft将一致性算法分解成了几个关键模块，包括领导者选举、日志复制和安全性。 Raft算法定义了Follower、Candidate和Leader三个角色，服务节点可以在这三个状态进行切换。 Raft算法最著名的实现是etcd/raft和hashicorp/raft，前者是">
<meta name="keywords" content="Raft">
<meta property="og:type" content="article">
<meta property="og:title" content="Copycat Raft之领导者选举">
<meta property="og:url" content="http://yoursite.com/2018/06/29/Copycat-Raft之领导选举/index.html">
<meta property="og:site_name" content="TechLiving">
<meta property="og:description" content="Raft是一种基于日志复制的分布式一致性算法，它提供了和Paxos算法相同的功能和性能，但更容易理解并且更容易构建实际的系统。Raft将一致性算法分解成了几个关键模块，包括领导者选举、日志复制和安全性。 Raft算法定义了Follower、Candidate和Leader三个角色，服务节点可以在这三个状态进行切换。 Raft算法最著名的实现是etcd/raft和hashicorp/raft，前者是">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/06/29/Copycat-Raft之领导选举/raft-states.png">
<meta property="og:image" content="http://yoursite.com/2018/06/29/Copycat-Raft之领导选举/copycat-leader%20selection.png">
<meta property="og:updated_time" content="2018-06-29T13:31:22.645Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Copycat Raft之领导者选举">
<meta name="twitter:description" content="Raft是一种基于日志复制的分布式一致性算法，它提供了和Paxos算法相同的功能和性能，但更容易理解并且更容易构建实际的系统。Raft将一致性算法分解成了几个关键模块，包括领导者选举、日志复制和安全性。 Raft算法定义了Follower、Candidate和Leader三个角色，服务节点可以在这三个状态进行切换。 Raft算法最著名的实现是etcd/raft和hashicorp/raft，前者是">
<meta name="twitter:image" content="http://yoursite.com/2018/06/29/Copycat-Raft之领导选举/raft-states.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/29/Copycat-Raft之领导选举/"/>





  <title>Copycat Raft之领导者选举 | TechLiving</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">TechLiving</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Technology and Life</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/29/Copycat-Raft之领导选举/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liao Rui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TechLiving">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Copycat Raft之领导者选举</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-29T09:19:22+08:00">
                2018-06-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/29/Copycat-Raft之领导选举/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/29/Copycat-Raft之领导选举/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Raft是一种基于日志复制的分布式一致性算法，它提供了和Paxos算法相同的功能和性能，但更容易理解并且更容易构建实际的系统。Raft将一致性算法分解成了几个关键模块，包括领导者选举、日志复制和安全性。</p>
<p>Raft算法定义了Follower、Candidate和Leader三个角色，服务节点可以在这三个状态进行切换。<br><img src="/2018/06/29/Copycat-Raft之领导选举/raft-states.png" alt=""></p>
<p>Raft算法最著名的实现是<a href="https://github.com/coreos/etcd/tree/master/raft" target="_blank" rel="noopener">etcd/raft</a>和<a href="https://github.com/hashicorp/raft" target="_blank" rel="noopener">hashicorp/raft</a>，前者是<a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">etcd</a>的实现基础，后者是<a href="https://github.com/hashicorp/consul" target="_blank" rel="noopener">consul</a>的实现基础。它们都是用Go语言实现的，更多语言实现请参见 <a href="https://raft.github.io。" target="_blank" rel="noopener">https://raft.github.io。</a></p>
<p><a href="https://github.com/atomix/copycat" target="_blank" rel="noopener">copycat</a>是raft的一个Java实现，实现了领导者选举、日志复制、角色切换和日志压缩等功能。</p>
<p>下面结合源码分析一下copycat对领导者选举的实现过程。</p>
<p><img src="/2018/06/29/Copycat-Raft之领导选举/copycat-leader selection.png" alt=""></p>
<p>通过CopycatServer.builder()方法构造CopycatServer实例，再通过bootstrap()方法启动。bootstrap()方法会调用ClusterState类的bootstrap()方法，注意所有ServerMember的type是ACTIVE类型的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Create a set of cluster members, excluding the local member which is joining a cluster.</span><br><span class="line">Set&lt;Member&gt; activeMembers = cluster.stream()</span><br><span class="line">    .filter(m -&gt; !m.equals(member.serverAddress()))</span><br><span class="line">    .map(m -&gt; new ServerMember(Member.Type.ACTIVE, m, null, member.updated()))</span><br><span class="line">    .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure></p>
<p>ClusterState的join()方法里继续调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Transition the server to the appropriate state for the local member type.</span><br><span class="line">context.transition(member.type());</span><br></pre></td></tr></table></figure></p>
<p>这里的context是ServerContext类的实例，member.type()是ACTIVE。transition()方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">protected void transition(Member.Type type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">      case ACTIVE:</span><br><span class="line">        if (!(state instanceof ActiveState)) &#123;</span><br><span class="line">          transition(CopycatServer.State.FOLLOWER);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      case PASSIVE:</span><br><span class="line">        if (this.state.type() != CopycatServer.State.PASSIVE) &#123;</span><br><span class="line">          transition(CopycatServer.State.PASSIVE);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      case RESERVE:</span><br><span class="line">        if (this.state.type() != CopycatServer.State.RESERVE) &#123;</span><br><span class="line">          transition(CopycatServer.State.RESERVE);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        if (this.state.type() != CopycatServer.State.INACTIVE) &#123;</span><br><span class="line">          transition(CopycatServer.State.INACTIVE);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * Transition handler.</span><br><span class="line">   */</span><br><span class="line">public void transition(CopycatServer.State state) &#123;</span><br><span class="line">    ......</span><br><span class="line">    this.state = createState(state);</span><br><span class="line">    this.state.open().get();</span><br><span class="line">.   .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * Creates an internal state for the given state type.</span><br><span class="line">   */</span><br><span class="line">private AbstractState createState(CopycatServer.State state) &#123;</span><br><span class="line">    switch (state) &#123;</span><br><span class="line">      case INACTIVE:</span><br><span class="line">        return new InactiveState(this);</span><br><span class="line">      case RESERVE:</span><br><span class="line">        return new ReserveState(this);</span><br><span class="line">      case PASSIVE:</span><br><span class="line">        return new PassiveState(this);</span><br><span class="line">      case FOLLOWER:</span><br><span class="line">        return new FollowerState(this);</span><br><span class="line">      case CANDIDATE:</span><br><span class="line">        return new CandidateState(this);</span><br><span class="line">      case LEADER:</span><br><span class="line">        return new LeaderState(this);</span><br><span class="line">      default:</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ACTIVE类型下对应FOLLOWER的状态，通过createState()创建了FollowerState对象，然后调用FollowerState对象的open()方法。FollowerState会调用sendPollRequest()方法去集群上检查所有成员的状态，并决定该CopycatServer是否切换到Candidate角色。</p>
<p>此时集群还没有其它的成员，第一个CopycatServer将自动切换到Candidata角色，调用context.transition(CopycatServer.State.CANDIDATE)方法。</p>
<p>通过transition(CANDIDATE)生成了CandidataState对象，再通过open()调用sendVoteRequests()方法发起投票。<br>该候选人会先把自己的任期号term加1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// When the election timer is reset, increment the current term and restart the election.</span><br><span class="line">context.setTerm(context.getTerm() + 1).setLastVotedFor(context.getCluster().member().id());</span><br></pre></td></tr></table></figure></p>
<p>如果集群还没有其它成员，则该候选人自动成为leader。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// If there are no other members in the cluster, immediately transition to leader.</span><br><span class="line">if (votingMembers.isEmpty()) &#123;</span><br><span class="line">  LOGGER.trace(&quot;&#123;&#125; - Single member cluster. Transitioning directly to leader.&quot;, context.getCluster().member().address());</span><br><span class="line">  context.transition(CopycatServer.State.LEADER);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果集群里有其它成员，则向集群所有成员发送投票请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Send vote requests to all nodes. The vote request that is sent</span><br><span class="line">// to this node will be automatically successful.</span><br><span class="line">// First check if the quorum is null. If the quorum isn&apos;t null then that</span><br><span class="line">// indicates that another vote is already going on.</span><br><span class="line">final Quorum quorum = new Quorum(context.getClusterState().getQuorum(), (elected) -&gt; &#123;</span><br><span class="line">  complete.set(true);</span><br><span class="line">  if (elected) &#123;</span><br><span class="line">    context.transition(CopycatServer.State.LEADER);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    context.transition(CopycatServer.State.FOLLOWER);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Once we got the last log term, iterate through each current member</span><br><span class="line">// of the cluster and vote each member for a vote.</span><br><span class="line">for (ServerMember member : votingMembers) &#123;</span><br><span class="line">  LOGGER.debug(&quot;&#123;&#125; - Requesting vote from &#123;&#125; for term &#123;&#125;&quot;, context.getCluster().member().address(), member, context.getTerm());</span><br><span class="line">  VoteRequest request = VoteRequest.builder()</span><br><span class="line">    .withTerm(context.getTerm())</span><br><span class="line">    .withCandidate(context.getCluster().member().id())</span><br><span class="line">    .withLogIndex(lastIndex)</span><br><span class="line">    .withLogTerm(lastTerm)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">  context.getConnections().getConnection(member.serverAddress()).thenAccept(connection -&gt; &#123;</span><br><span class="line">    connection.&lt;VoteRequest, VoteResponse&gt;sendAndReceive(request).whenCompleteAsync((response, error) -&gt; &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;, context.getThreadContext().executor());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个服务节点会监听来自其它节点的请求，通过CopycatServer的start()和listen()方法来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Starts listening the server.</span><br><span class="line">*/</span><br><span class="line">private CompletableFuture&lt;Void&gt; listen() &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = new CompletableFuture&lt;&gt;();</span><br><span class="line">    context.getThreadContext().executor().execute(() -&gt; &#123;</span><br><span class="line">      internalServer.listen(cluster().member().serverAddress(), context::connectServer).whenComplete((internalResult, internalError) -&gt; &#123;</span><br><span class="line">        if (internalError == null) &#123;</span><br><span class="line">          // If the client address is different than the server address, start a separate client server.</span><br><span class="line">          if (clientServer != null) &#123;</span><br><span class="line">            clientServer.listen(cluster().member().clientAddress(), context::connectClient).whenComplete((clientResult, clientError) -&gt; &#123;</span><br><span class="line">              started = true;</span><br><span class="line">              future.complete(null);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            started = true;</span><br><span class="line">            future.complete(null);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          future.completeExceptionally(internalError);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，connectClient是在ServerContext类中定义的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Handles a connection from another server.</span><br><span class="line">*/</span><br><span class="line">public void connectServer(Connection connection) &#123;</span><br><span class="line">    threadContext.checkThread();</span><br><span class="line"></span><br><span class="line">    // Handlers for all request types are registered since requests can be proxied between servers.</span><br><span class="line">    // Note we do not use method references here because the &quot;state&quot; variable changes over time.</span><br><span class="line">    // We have to use lambdas to ensure the request handler points to the current state.</span><br><span class="line">    connection.handler(RegisterRequest.class, (Function&lt;RegisterRequest, CompletableFuture&lt;RegisterResponse&gt;&gt;) request -&gt; state.register(request));</span><br><span class="line">    connection.handler(ConnectRequest.class, (Function&lt;ConnectRequest, CompletableFuture&lt;ConnectResponse&gt;&gt;) request -&gt; state.connect(request, connection));</span><br><span class="line">    connection.handler(KeepAliveRequest.class, (Function&lt;KeepAliveRequest, CompletableFuture&lt;KeepAliveResponse&gt;&gt;) request -&gt; state.keepAlive(request));</span><br><span class="line">    connection.handler(UnregisterRequest.class, (Function&lt;UnregisterRequest, CompletableFuture&lt;UnregisterResponse&gt;&gt;) request -&gt; state.unregister(request));</span><br><span class="line">    connection.handler(ResetRequest.class, (Consumer&lt;ResetRequest&gt;) request -&gt; state.reset(request));</span><br><span class="line">    connection.handler(ConfigureRequest.class, (Function&lt;ConfigureRequest, CompletableFuture&lt;ConfigureResponse&gt;&gt;) request -&gt; state.configure(request));</span><br><span class="line">    connection.handler(InstallRequest.class, (Function&lt;InstallRequest, CompletableFuture&lt;InstallResponse&gt;&gt;) request -&gt; state.install(request));</span><br><span class="line">    connection.handler(JoinRequest.class, (Function&lt;JoinRequest, CompletableFuture&lt;JoinResponse&gt;&gt;) request -&gt; state.join(request));</span><br><span class="line">    connection.handler(ReconfigureRequest.class, (Function&lt;ReconfigureRequest, CompletableFuture&lt;ReconfigureResponse&gt;&gt;) request -&gt; state.reconfigure(request));</span><br><span class="line">    connection.handler(LeaveRequest.class, (Function&lt;LeaveRequest, CompletableFuture&lt;LeaveResponse&gt;&gt;) request -&gt; state.leave(request));</span><br><span class="line">    connection.handler(AppendRequest.class, (Function&lt;AppendRequest, CompletableFuture&lt;AppendResponse&gt;&gt;) request -&gt; state.append(request));</span><br><span class="line">    connection.handler(PollRequest.class, (Function&lt;PollRequest, CompletableFuture&lt;PollResponse&gt;&gt;) request -&gt; state.poll(request));</span><br><span class="line">    connection.handler(VoteRequest.class, (Function&lt;VoteRequest, CompletableFuture&lt;VoteResponse&gt;&gt;) request -&gt; state.vote(request));</span><br><span class="line">    connection.handler(CommandRequest.class, (Function&lt;CommandRequest, CompletableFuture&lt;CommandResponse&gt;&gt;) request -&gt; state.command(request));</span><br><span class="line">    connection.handler(QueryRequest.class, (Function&lt;QueryRequest, CompletableFuture&lt;QueryResponse&gt;&gt;) request -&gt; state.query(request));</span><br><span class="line"></span><br><span class="line">    connection.onClose(stateMachine.executor().context().sessions()::unregisterConnection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>投票请求对于VoteRequest类，会调用ActiveState的vote()方法来处理。ActiveState是FollowerState、CandidateState和LeaderState的超类。对于Follower，并没有重写vote方法，直接调用父类ActiveState的实现来处理。</p>
<p>ActiveState类的vote()方法会继续调用handleVote()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Handles a vote request.</span><br><span class="line">*/</span><br><span class="line">protected VoteResponse handleVote(VoteRequest request) &#123;</span><br><span class="line">    // If the request term is not as great as the current context term then don&apos;t</span><br><span class="line">    // vote for the candidate. We want to vote for candidates that are at least</span><br><span class="line">    // as up to date as us.</span><br><span class="line">    if (request.term() &lt; context.getTerm()) &#123;</span><br><span class="line">      LOGGER.trace(&quot;&#123;&#125; - Rejected &#123;&#125;: candidate&apos;s term is less than the current term&quot;, context.getCluster().member().address(), request);</span><br><span class="line">      return VoteResponse.builder()</span><br><span class="line">        .withStatus(Response.Status.OK)</span><br><span class="line">        .withTerm(context.getTerm())</span><br><span class="line">        .withVoted(false)</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line">    // If a leader was already determined for this term then reject the request.</span><br><span class="line">    else if (context.getLeader() != null) &#123;</span><br><span class="line">      LOGGER.trace(&quot;&#123;&#125; - Rejected &#123;&#125;: leader already exists&quot;, context.getCluster().member().address(), request);</span><br><span class="line">      return VoteResponse.builder()</span><br><span class="line">        .withStatus(Response.Status.OK)</span><br><span class="line">        .withTerm(context.getTerm())</span><br><span class="line">        .withVoted(false)</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line">    // If the requesting candidate is not a known member of the cluster (to this</span><br><span class="line">    // node) then don&apos;t vote for it. Only vote for candidates that we know about.</span><br><span class="line">    else if (!context.getClusterState().getRemoteMemberStates().stream().&lt;Integer&gt;map(m -&gt; m.getMember().id()).collect(Collectors.toSet()).contains(request.candidate())) &#123;</span><br><span class="line">      LOGGER.trace(&quot;&#123;&#125; - Rejected &#123;&#125;: candidate is not known to the local member&quot;, context.getCluster().member().address(), request);</span><br><span class="line">      return VoteResponse.builder()</span><br><span class="line">        .withStatus(Response.Status.OK)</span><br><span class="line">        .withTerm(context.getTerm())</span><br><span class="line">        .withVoted(false)</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line">    // If no vote has been cast, check the log and cast a vote if necessary.</span><br><span class="line">    else if (context.getLastVotedFor() == 0) &#123;</span><br><span class="line">      if (isLogUpToDate(request.logIndex(), request.logTerm(), request)) &#123;</span><br><span class="line">        context.setLastVotedFor(request.candidate());</span><br><span class="line">        return VoteResponse.builder()</span><br><span class="line">          .withStatus(Response.Status.OK)</span><br><span class="line">          .withTerm(context.getTerm())</span><br><span class="line">          .withVoted(true)</span><br><span class="line">          .build();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return VoteResponse.builder()</span><br><span class="line">          .withStatus(Response.Status.OK)</span><br><span class="line">          .withTerm(context.getTerm())</span><br><span class="line">          .withVoted(false)</span><br><span class="line">          .build();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // If we already voted for the requesting server, respond successfully.</span><br><span class="line">    else if (context.getLastVotedFor() == request.candidate()) &#123;</span><br><span class="line">      LOGGER.debug(&quot;&#123;&#125; - Accepted &#123;&#125;: already voted for &#123;&#125;&quot;, context.getCluster().member().address(), request, context.getCluster().member(context.getLastVotedFor()).address());</span><br><span class="line">      return VoteResponse.builder()</span><br><span class="line">        .withStatus(Response.Status.OK)</span><br><span class="line">        .withTerm(context.getTerm())</span><br><span class="line">        .withVoted(true)</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line">    // In this case, we&apos;ve already voted for someone else.</span><br><span class="line">    else &#123;</span><br><span class="line">      LOGGER.debug(&quot;&#123;&#125; - Rejected &#123;&#125;: already voted for &#123;&#125;&quot;, context.getCluster().member().address(), request, context.getCluster().member(context.getLastVotedFor()).address());</span><br><span class="line">      return VoteResponse.builder()</span><br><span class="line">        .withStatus(Response.Status.OK)</span><br><span class="line">        .withTerm(context.getTerm())</span><br><span class="line">        .withVoted(false)</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果该候选人赢得了选举，则通过context.transition(CopycatServer.State.LEADER)成为领导者，否则继续回退到FOLLOWER角色。</p>
<p>当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。</p>
<p>在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项RPC。如果这个领导人的任期号（包含在此次的RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。如果此次RPC中的任期号比自己小，那么候选人就会拒绝这次的RPC并且继续保持候选人状态。</p>
<p>有一种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</p>
<p>Raft算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。</p>
<p>当候选人成为领导者时，会创建LeaderState实例，并调用open方法，写入InitializeEntry日志，然后调用context.getStateMachine().apply(resultIndex)在状态机中应用该状态。最后通过startAppendTimer()循环调用LeaderAppender类的appendMembers()方法，告诉其它节点“我是领导者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void appendEntries(MemberState member) &#123;</span><br><span class="line">    // Prevent recursive, asynchronous appends from being executed if the appender has been closed.</span><br><span class="line">    if (!open)</span><br><span class="line">      return;</span><br><span class="line"></span><br><span class="line">    // If prior requests to the member have failed, build an empty append request to send to the member</span><br><span class="line">    // to prevent having to read from disk to configure, install, or append to an unavailable member.</span><br><span class="line">    if (member.getFailureCount() &gt;= MINIMUM_BACKOFF_FAILURE_COUNT) &#123;</span><br><span class="line">      // To prevent the leader from unnecessarily attempting to connect to a down follower on every heartbeat,</span><br><span class="line">      // use exponential backoff to back off up to 60 second heartbeat intervals.</span><br><span class="line">      if (System.currentTimeMillis() - member.getHeartbeatStartTime() &gt; Math.min(heartbeatInterval * Math.pow(2, member.getFailureCount()), MAX_HEARTBEAT_WAIT)) &#123;</span><br><span class="line">        sendAppendRequest(member, buildAppendEmptyRequest(member));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // If the member term is less than the current term or the member&apos;s configuration index is less</span><br><span class="line">    // than the local configuration index, send a configuration update to the member.</span><br><span class="line">    // Ensure that only one configuration attempt per member is attempted at any given time by storing the</span><br><span class="line">    // member state in a set of configuring members.</span><br><span class="line">    // Once the configuration is complete sendAppendRequest will be called recursively.</span><br><span class="line">    else if (member.getConfigTerm() &lt; context.getTerm() || member.getConfigIndex() &lt; context.getClusterState().getConfiguration().index()) &#123;</span><br><span class="line">      if (member.canConfigure()) &#123;</span><br><span class="line">        sendConfigureRequest(member, buildConfigureRequest(member));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // If the member is a reserve or passive member, send an empty AppendRequest to it.</span><br><span class="line">    else if (member.getMember().type() == Member.Type.RESERVE || member.getMember().type() == Member.Type.PASSIVE) &#123;</span><br><span class="line">      if (member.canAppend()) &#123;</span><br><span class="line">        sendAppendRequest(member, buildAppendEmptyRequest(member));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // If the member&apos;s current snapshot index is less than the latest snapshot index and the latest snapshot index</span><br><span class="line">    // is less than the nextIndex, send a snapshot request.</span><br><span class="line">    else if (member.getMember().type() == Member.Type.ACTIVE &amp;&amp; context.getSnapshotStore().currentSnapshot() != null</span><br><span class="line">      &amp;&amp; context.getSnapshotStore().currentSnapshot().index() &gt;= member.getNextIndex()</span><br><span class="line">      &amp;&amp; context.getSnapshotStore().currentSnapshot().index() &gt; member.getSnapshotIndex()) &#123;</span><br><span class="line">      if (member.canInstall()) &#123;</span><br><span class="line">        sendInstallRequest(member, buildInstallRequest(member));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // If no AppendRequest is already being sent, send an AppendRequest.</span><br><span class="line">    else if (member.canAppend()) &#123;</span><br><span class="line">      sendAppendRequest(member, buildAppendRequest(member, context.getLog().lastIndex()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>其它节点收到消息后，则以Follower身份不断接收Leader的消息，进行日志同步复制，Copycat的领导者选举过程到此结束。</p>
<p>关于raft算法的更多细节，可以参考 <a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</a> 这篇文章。</p>
<p>后面再分析日志同步和日志压缩过程。</p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/weixin_qrcode.jpg" alt="Liao Rui wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎关注我的微信公众号《技术与生活小站》</div>
</div>

      </div>
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Raft/" rel="tag"># Raft</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/16/CentOS-7离线安装Kubernetes/" rel="next" title="CentOS-7离线安装Kubernetes">
                <i class="fa fa-chevron-left"></i> CentOS-7离线安装Kubernetes
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/11/分布式ID生成服务-Snowflake/" rel="prev" title="分布式ID生成服务-Snowflake">
                分布式ID生成服务-Snowflake <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      

    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpeg"
                alt="Liao Rui" />
            
              <p class="site-author-name" itemprop="name">Liao Rui</p>
              <p class="site-description motion-element" itemprop="description">Java</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liao Rui</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'gBKAh0rYcnxSinc8tu0HIpLg-gzGzoHsz',
        appKey: 'mIuTlwW0NmX5kNaFXMqCCEPi',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
